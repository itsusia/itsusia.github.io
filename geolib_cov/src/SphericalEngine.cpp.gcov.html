<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - main_coverage.info - src/SphericalEngine.cpp</title>
  <link rel="stylesheet" type="text/css" href="../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../index.html">top level</a> - <a href="index.html">src</a> - SphericalEngine.cpp<span style="font-size: 80%;"> (source / <a href="SphericalEngine.cpp.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">main_coverage.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">132</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2019-11-14 17:15:21</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">27</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr><td><img src="../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /**</a>
<span class="lineNum">       2 </span>            :  * \file SphericalEngine.cpp
<span class="lineNum">       3 </span>            :  * \brief Implementation for GeographicLib::SphericalEngine class
<span class="lineNum">       4 </span>            :  *
<span class="lineNum">       5 </span>            :  * Copyright (c) Charles Karney (2011-2017) &lt;charles@karney.com&gt; and licensed
<span class="lineNum">       6 </span>            :  * under the MIT/X11 License.  For more information, see
<span class="lineNum">       7 </span>            :  * https://geographiclib.sourceforge.io/
<span class="lineNum">       8 </span>            :  *
<span class="lineNum">       9 </span>            :  * The general sum is\verbatim
<span class="lineNum">      10 </span>            :  V(r, theta, lambda) = sum(n = 0..N) sum(m = 0..n)
<span class="lineNum">      11 </span>            :    q^(n+1) * (C[n,m] * cos(m*lambda) + S[n,m] * sin(m*lambda)) * P[n,m](t)
<span class="lineNum">      12 </span>            : \endverbatim
<span class="lineNum">      13 </span>            :  * where &lt;tt&gt;t = cos(theta)&lt;/tt&gt;, &lt;tt&gt;q = a/r&lt;/tt&gt;.  In addition write &lt;tt&gt;u =
<span class="lineNum">      14 </span>            :  * sin(theta)&lt;/tt&gt;.
<span class="lineNum">      15 </span>            :  *
<span class="lineNum">      16 </span>            :  * &lt;tt&gt;P[n,m]&lt;/tt&gt; is a normalized associated Legendre function of degree
<span class="lineNum">      17 </span>            :  * &lt;tt&gt;n&lt;/tt&gt; and order &lt;tt&gt;m&lt;/tt&gt;.  Here the formulas are given for full
<span class="lineNum">      18 </span>            :  * normalized functions (usually denoted &lt;tt&gt;Pbar&lt;/tt&gt;).
<span class="lineNum">      19 </span>            :  *
<span class="lineNum">      20 </span>            :  * Rewrite outer sum\verbatim
<span class="lineNum">      21 </span>            :  V(r, theta, lambda) = sum(m = 0..N) * P[m,m](t) * q^(m+1) *
<span class="lineNum">      22 </span>            :     [Sc[m] * cos(m*lambda) + Ss[m] * sin(m*lambda)]
<span class="lineNum">      23 </span>            : \endverbatim
<span class="lineNum">      24 </span>            :  * where the inner sums are\verbatim
<span class="lineNum">      25 </span>            :    Sc[m] = sum(n = m..N) q^(n-m) * C[n,m] * P[n,m](t)/P[m,m](t)
<span class="lineNum">      26 </span>            :    Ss[m] = sum(n = m..N) q^(n-m) * S[n,m] * P[n,m](t)/P[m,m](t)
<span class="lineNum">      27 </span>            : \endverbatim
<span class="lineNum">      28 </span>            :  * Evaluate sums via Clenshaw method.  The overall framework is similar to
<span class="lineNum">      29 </span>            :  * Deakin with the following changes:
<span class="lineNum">      30 </span>            :  * - Clenshaw summation is used to roll the computation of
<span class="lineNum">      31 </span>            :  *   &lt;tt&gt;cos(m*lambda)&lt;/tt&gt; and &lt;tt&gt;sin(m*lambda)&lt;/tt&gt; into the evaluation of
<span class="lineNum">      32 </span>            :  *   the outer sum (rather than independently computing an array of these
<span class="lineNum">      33 </span>            :  *   trigonometric terms).
<span class="lineNum">      34 </span>            :  * - Scale the coefficients to guard against overflow when &lt;tt&gt;N&lt;/tt&gt; is large.
<span class="lineNum">      35 </span>            :  * .
<span class="lineNum">      36 </span>            :  * For the general framework of Clenshaw, see
<span class="lineNum">      37 </span>            :  * http://mathworld.wolfram.com/ClenshawRecurrenceFormula.html
<span class="lineNum">      38 </span>            :  *
<span class="lineNum">      39 </span>            :  * Let\verbatim
<span class="lineNum">      40 </span>            :     S = sum(k = 0..N) c[k] * F[k](x)
<span class="lineNum">      41 </span>            :     F[n+1](x) = alpha[n](x) * F[n](x) + beta[n](x) * F[n-1](x)
<span class="lineNum">      42 </span>            : \endverbatim
<span class="lineNum">      43 </span>            :  * Evaluate &lt;tt&gt;S&lt;/tt&gt; with\verbatim
<span class="lineNum">      44 </span>            :     y[N+2] = y[N+1] = 0
<span class="lineNum">      45 </span>            :     y[k] = alpha[k] * y[k+1] + beta[k+1] * y[k+2] + c[k]
<span class="lineNum">      46 </span>            :     S = c[0] * F[0] + y[1] * F[1] + beta[1] * F[0] * y[2]
<span class="lineNum">      47 </span>            : \endverbatim
<span class="lineNum">      48 </span>            :  * \e IF &lt;tt&gt;F[0](x) = 1&lt;/tt&gt; and &lt;tt&gt;beta(0,x) = 0&lt;/tt&gt;, then &lt;tt&gt;F[1](x) =
<span class="lineNum">      49 </span>            :  * alpha(0,x)&lt;/tt&gt; and we can continue the recursion for &lt;tt&gt;y[k]&lt;/tt&gt; until
<span class="lineNum">      50 </span>            :  * &lt;tt&gt;y[0]&lt;/tt&gt;, giving\verbatim
<span class="lineNum">      51 </span>            :     S = y[0]
<span class="lineNum">      52 </span>            : \endverbatim
<span class="lineNum">      53 </span>            :  *
<span class="lineNum">      54 </span>            :  * Evaluating the inner sum\verbatim
<span class="lineNum">      55 </span>            :  l = n-m; n = l+m
<span class="lineNum">      56 </span>            :  Sc[m] = sum(l = 0..N-m) C[l+m,m] * q^l * P[l+m,m](t)/P[m,m](t)
<span class="lineNum">      57 </span>            :  F[l] = q^l * P[l+m,m](t)/P[m,m](t)
<span class="lineNum">      58 </span>            : \endverbatim
<span class="lineNum">      59 </span>            :  * Holmes + Featherstone, Eq. (11), give\verbatim
<span class="lineNum">      60 </span>            :    P[n,m] = sqrt((2*n-1)*(2*n+1)/((n-m)*(n+m))) * t * P[n-1,m] -
<span class="lineNum">      61 </span>            :             sqrt((2*n+1)*(n+m-1)*(n-m-1)/((n-m)*(n+m)*(2*n-3))) * P[n-2,m]
<span class="lineNum">      62 </span>            : \endverbatim
<span class="lineNum">      63 </span>            :  * thus\verbatim
<span class="lineNum">      64 </span>            :    alpha[l] = t * q * sqrt(((2*n+1)*(2*n+3))/
<span class="lineNum">      65 </span>            :                            ((n-m+1)*(n+m+1)))
<span class="lineNum">      66 </span>            :    beta[l+1] = - q^2 * sqrt(((n-m+1)*(n+m+1)*(2*n+5))/
<span class="lineNum">      67 </span>            :                             ((n-m+2)*(n+m+2)*(2*n+1)))
<span class="lineNum">      68 </span>            : \endverbatim
<span class="lineNum">      69 </span>            :  * In this case, &lt;tt&gt;F[0] = 1&lt;/tt&gt; and &lt;tt&gt;beta[0] = 0&lt;/tt&gt;, so the &lt;tt&gt;Sc[m]
<span class="lineNum">      70 </span>            :  * = y[0]&lt;/tt&gt;.
<span class="lineNum">      71 </span>            :  *
<span class="lineNum">      72 </span>            :  * Evaluating the outer sum\verbatim
<span class="lineNum">      73 </span>            :  V = sum(m = 0..N) Sc[m] * q^(m+1) * cos(m*lambda) * P[m,m](t)
<span class="lineNum">      74 </span>            :    + sum(m = 0..N) Ss[m] * q^(m+1) * cos(m*lambda) * P[m,m](t)
<span class="lineNum">      75 </span>            :  F[m] = q^(m+1) * cos(m*lambda) * P[m,m](t) [or sin(m*lambda)]
<span class="lineNum">      76 </span>            : \endverbatim
<span class="lineNum">      77 </span>            :  * Holmes + Featherstone, Eq. (13), give\verbatim
<span class="lineNum">      78 </span>            :    P[m,m] = u * sqrt((2*m+1)/((m&gt;1?2:1)*m)) * P[m-1,m-1]
<span class="lineNum">      79 </span>            : \endverbatim
<span class="lineNum">      80 </span>            :  * also, we have\verbatim
<span class="lineNum">      81 </span>            :    cos((m+1)*lambda) = 2*cos(lambda)*cos(m*lambda) - cos((m-1)*lambda)
<span class="lineNum">      82 </span>            : \endverbatim
<span class="lineNum">      83 </span>            :  * thus\verbatim
<span class="lineNum">      84 </span>            :    alpha[m] = 2*cos(lambda) * sqrt((2*m+3)/(2*(m+1))) * u * q
<span class="lineNum">      85 </span>            :             =   cos(lambda) * sqrt( 2*(2*m+3)/(m+1) ) * u * q
<span class="lineNum">      86 </span>            :    beta[m+1] = -sqrt((2*m+3)*(2*m+5)/(4*(m+1)*(m+2))) * u^2 * q^2
<span class="lineNum">      87 </span>            :                * (m == 0 ? sqrt(2) : 1)
<span class="lineNum">      88 </span>            : \endverbatim
<span class="lineNum">      89 </span>            :  * Thus\verbatim
<span class="lineNum">      90 </span>            :  F[0] = q                                [or 0]
<span class="lineNum">      91 </span>            :  F[1] = cos(lambda) * sqrt(3) * u * q^2  [or sin(lambda)]
<span class="lineNum">      92 </span>            :  beta[1] = - sqrt(15/4) * u^2 * q^2
<span class="lineNum">      93 </span>            : \endverbatim
<span class="lineNum">      94 </span>            :  *
<span class="lineNum">      95 </span>            :  * Here is how the various components of the gradient are computed
<span class="lineNum">      96 </span>            :  *
<span class="lineNum">      97 </span>            :  * Differentiate wrt &lt;tt&gt;r&lt;/tt&gt;\verbatim
<span class="lineNum">      98 </span>            :    d q^(n+1) / dr = (-1/r) * (n+1) * q^(n+1)
<span class="lineNum">      99 </span>            : \endverbatim
<span class="lineNum">     100 </span>            :  * so multiply &lt;tt&gt;C[n,m]&lt;/tt&gt; by &lt;tt&gt;n+1&lt;/tt&gt; in inner sum and multiply the
<span class="lineNum">     101 </span>            :  * sum by &lt;tt&gt;-1/r&lt;/tt&gt;.
<span class="lineNum">     102 </span>            :  *
<span class="lineNum">     103 </span>            :  * Differentiate wrt &lt;tt&gt;lambda&lt;/tt&gt;\verbatim
<span class="lineNum">     104 </span>            :    d cos(m*lambda) = -m * sin(m*lambda)
<span class="lineNum">     105 </span>            :    d sin(m*lambda) =  m * cos(m*lambda)
<span class="lineNum">     106 </span>            : \endverbatim
<span class="lineNum">     107 </span>            :  * so multiply terms by &lt;tt&gt;m&lt;/tt&gt; in outer sum and swap sine and cosine
<span class="lineNum">     108 </span>            :  * variables.
<span class="lineNum">     109 </span>            :  *
<span class="lineNum">     110 </span>            :  * Differentiate wrt &lt;tt&gt;theta&lt;/tt&gt;\verbatim
<span class="lineNum">     111 </span>            :   dV/dtheta = V' = -u * dV/dt = -u * V'
<span class="lineNum">     112 </span>            : \endverbatim
<span class="lineNum">     113 </span>            :  * here &lt;tt&gt;'&lt;/tt&gt; denotes differentiation wrt &lt;tt&gt;theta&lt;/tt&gt;.\verbatim
<span class="lineNum">     114 </span>            :    d/dtheta (Sc[m] * P[m,m](t)) = Sc'[m] * P[m,m](t) + Sc[m] * P'[m,m](t)
<span class="lineNum">     115 </span>            : \endverbatim
<span class="lineNum">     116 </span>            :  * Now &lt;tt&gt;P[m,m](t) = const * u^m&lt;/tt&gt;, so &lt;tt&gt;P'[m,m](t) = m * t/u *
<span class="lineNum">     117 </span>            :  * P[m,m](t)&lt;/tt&gt;, thus\verbatim
<span class="lineNum">     118 </span>            :    d/dtheta (Sc[m] * P[m,m](t)) = (Sc'[m] + m * t/u * Sc[m]) * P[m,m](t)
<span class="lineNum">     119 </span>            : \endverbatim
<span class="lineNum">     120 </span>            :  * Clenshaw recursion for &lt;tt&gt;Sc[m]&lt;/tt&gt; reads\verbatim
<span class="lineNum">     121 </span>            :     y[k] = alpha[k] * y[k+1] + beta[k+1] * y[k+2] + c[k]
<span class="lineNum">     122 </span>            : \endverbatim
<span class="lineNum">     123 </span>            :  * Substituting &lt;tt&gt;alpha[k] = const * t&lt;/tt&gt;, &lt;tt&gt;alpha'[k] = -u/t *
<span class="lineNum">     124 </span>            :  * alpha[k]&lt;/tt&gt;, &lt;tt&gt;beta'[k] = c'[k] = 0&lt;/tt&gt; gives\verbatim
<span class="lineNum">     125 </span>            :     y'[k] = alpha[k] * y'[k+1] + beta[k+1] * y'[k+2] - u/t * alpha[k] * y[k+1]
<span class="lineNum">     126 </span>            : \endverbatim
<span class="lineNum">     127 </span>            :  *
<span class="lineNum">     128 </span>            :  * Finally, given the derivatives of &lt;tt&gt;V&lt;/tt&gt;, we can compute the components
<span class="lineNum">     129 </span>            :  * of the gradient in spherical coordinates and transform the result into
<span class="lineNum">     130 </span>            :  * cartesian coordinates.
<span class="lineNum">     131 </span>            :  **********************************************************************/
<span class="lineNum">     132 </span>            : 
<span class="lineNum">     133 </span>            : #include &lt;GeographicLib/SphericalEngine.hpp&gt;
<span class="lineNum">     134 </span>            : #include &lt;GeographicLib/CircularEngine.hpp&gt;
<span class="lineNum">     135 </span>            : #include &lt;GeographicLib/Utility.hpp&gt;
<span class="lineNum">     136 </span>            : 
<span class="lineNum">     137 </span>            : #if defined(_MSC_VER)
<span class="lineNum">     138 </span>            : // Squelch warnings about constant conditional expressions and potentially
<span class="lineNum">     139 </span>            : // uninitialized local variables
<span class="lineNum">     140 </span>            : #  pragma warning (disable: 4127 4701)
<span class="lineNum">     141 </span>            : #endif
<span class="lineNum">     142 </span>            : 
<span class="lineNum">     143 </span>            : namespace GeographicLib {
<span class="lineNum">     144 </span>            : 
<a name="145"><span class="lineNum">     145 </span>            :   using namespace std;</a>
<span class="lineNum">     146 </span>            : 
<span class="lineNum">     147 </span><span class="lineNoCov">          0 :   vector&lt;Math::real&gt;&amp; SphericalEngine::sqrttable() {</span>
<span class="lineNum">     148 </span><span class="lineNoCov">          0 :     static vector&lt;real&gt; sqrttable(0);</span>
<span class="lineNum">     149 </span><span class="lineNoCov">          0 :     return sqrttable;</span>
<span class="lineNum">     150 </span>            :   }
<span class="lineNum">     151 </span>            : 
<span class="lineNum">     152 </span>            :   template&lt;bool gradp, SphericalEngine::normalization norm, int L&gt;
<span class="lineNum">     153 </span><span class="lineNoCov">          0 :   Math::real SphericalEngine::Value(const coeff c[], const real f[],</span>
<span class="lineNum">     154 </span>            :                                     real x, real y, real z, real a,
<span class="lineNum">     155 </span>            :                                     real&amp; gradx, real&amp; grady, real&amp; gradz)
<span class="lineNum">     156 </span>            :     {
<span class="lineNum">     157 </span>            :     GEOGRAPHICLIB_STATIC_ASSERT(L &gt; 0, &quot;L must be positive&quot;);
<span class="lineNum">     158 </span>            :     GEOGRAPHICLIB_STATIC_ASSERT(norm == FULL || norm == SCHMIDT,
<span class="lineNum">     159 </span>            :                                 &quot;Unknown normalization&quot;);
<span class="lineNum">     160 </span><span class="lineNoCov">          0 :     int N = c[0].nmx(), M = c[0].mmx();</span>
<span class="lineNum">     161 </span>            : 
<span class="lineNum">     162 </span>            :     real
<span class="lineNum">     163 </span>            :       p = Math::hypot(x, y),
<span class="lineNum">     164 </span><span class="lineNoCov">          0 :       cl = p != 0 ? x / p : 1,  // cos(lambda); at pole, pick lambda = 0</span>
<span class="lineNum">     165 </span><span class="lineNoCov">          0 :       sl = p != 0 ? y / p : 0,  // sin(lambda)</span>
<span class="lineNum">     166 </span>            :       r = Math::hypot(z, p),
<span class="lineNum">     167 </span><span class="lineNoCov">          0 :       t = r != 0 ? z / r : 0,   // cos(theta); at origin, pick theta = pi/2</span>
<span class="lineNum">     168 </span><span class="lineNoCov">          0 :       u = r != 0 ? max(p / r, eps()) : 1, // sin(theta); but avoid the pole</span>
<span class="lineNum">     169 </span><span class="lineNoCov">          0 :       q = a / r;</span>
<span class="lineNum">     170 </span>            :     real
<span class="lineNum">     171 </span>            :       q2 = Math::sq(q),
<span class="lineNum">     172 </span><span class="lineNoCov">          0 :       uq = u * q,</span>
<span class="lineNum">     173 </span>            :       uq2 = Math::sq(uq),
<span class="lineNum">     174 </span><span class="lineNoCov">          0 :       tu = t / u;</span>
<span class="lineNum">     175 </span>            :     // Initialize outer sum
<span class="lineNum">     176 </span>            :     real vc  = 0, vc2  = 0, vs  = 0, vs2  = 0;   // v [N + 1], v [N + 2]
<span class="lineNum">     177 </span>            :     // vr, vt, vl and similar w variable accumulate the sums for the
<span class="lineNum">     178 </span>            :     // derivatives wrt r, theta, and lambda, respectively.
<span class="lineNum">     179 </span>            :     real vrc = 0, vrc2 = 0, vrs = 0, vrs2 = 0;   // vr[N + 1], vr[N + 2]
<span class="lineNum">     180 </span>            :     real vtc = 0, vtc2 = 0, vts = 0, vts2 = 0;   // vt[N + 1], vt[N + 2]
<span class="lineNum">     181 </span>            :     real vlc = 0, vlc2 = 0, vls = 0, vls2 = 0;   // vl[N + 1], vl[N + 2]
<span class="lineNum">     182 </span>            :     int k[L];
<span class="lineNum">     183 </span><span class="lineNoCov">          0 :     const vector&lt;real&gt;&amp; root( sqrttable() );</span>
<span class="lineNum">     184 </span><span class="lineNoCov">          0 :     for (int m = M; m &gt;= 0; --m) {   // m = M .. 0</span>
<span class="lineNum">     185 </span>            :       // Initialize inner sum
<span class="lineNum">     186 </span>            :       real
<span class="lineNum">     187 </span>            :         wc  = 0, wc2  = 0, ws  = 0, ws2  = 0, // w [N - m + 1], w [N - m + 2]
<span class="lineNum">     188 </span>            :         wrc = 0, wrc2 = 0, wrs = 0, wrs2 = 0, // wr[N - m + 1], wr[N - m + 2]
<span class="lineNum">     189 </span>            :         wtc = 0, wtc2 = 0, wts = 0, wts2 = 0; // wt[N - m + 1], wt[N - m + 2]
<span class="lineNum">     190 </span><span class="lineNoCov">          0 :       for (int l = 0; l &lt; L; ++l)</span>
<span class="lineNum">     191 </span><span class="lineNoCov">          0 :         k[l] = c[l].index(N, m) + 1;</span>
<span class="lineNum">     192 </span><span class="lineNoCov">          0 :       for (int n = N; n &gt;= m; --n) {             // n = N .. m; l = N - m .. 0</span>
<span class="lineNum">     193 </span>            :         real w, A, Ax, B, R;    // alpha[l], beta[l + 1]
<span class="lineNum">     194 </span>            :         switch (norm) {
<span class="lineNum">     195 </span><span class="lineNoCov">          0 :         case FULL:</span>
<span class="lineNum">     196 </span><span class="lineNoCov">          0 :           w = root[2 * n + 1] / (root[n - m + 1] * root[n + m + 1]);</span>
<span class="lineNum">     197 </span><span class="lineNoCov">          0 :           Ax = q * w * root[2 * n + 3];</span>
<span class="lineNum">     198 </span><span class="lineNoCov">          0 :           A = t * Ax;</span>
<span class="lineNum">     199 </span><span class="lineNoCov">          0 :           B = - q2 * root[2 * n + 5] /</span>
<span class="lineNum">     200 </span><span class="lineNoCov">          0 :             (w * root[n - m + 2] * root[n + m + 2]);</span>
<span class="lineNum">     201 </span>            :           break;
<span class="lineNum">     202 </span><span class="lineNoCov">          0 :         case SCHMIDT:</span>
<span class="lineNum">     203 </span><span class="lineNoCov">          0 :           w = root[n - m + 1] * root[n + m + 1];</span>
<span class="lineNum">     204 </span><span class="lineNoCov">          0 :           Ax = q * (2 * n + 1) / w;</span>
<span class="lineNum">     205 </span><span class="lineNoCov">          0 :           A = t * Ax;</span>
<span class="lineNum">     206 </span><span class="lineNoCov">          0 :           B = - q2 * w / (root[n - m + 2] * root[n + m + 2]);</span>
<span class="lineNum">     207 </span>            :           break;
<span class="lineNum">     208 </span>            :         default: break;       // To suppress warning message from Visual Studio
<span class="lineNum">     209 </span>            :         }
<span class="lineNum">     210 </span><span class="lineNoCov">          0 :         R = c[0].Cv(--k[0]);</span>
<span class="lineNum">     211 </span><span class="lineNoCov">          0 :         for (int l = 1; l &lt; L; ++l)</span>
<span class="lineNum">     212 </span><span class="lineNoCov">          0 :           R += c[l].Cv(--k[l], n, m, f[l]);</span>
<span class="lineNum">     213 </span><span class="lineNoCov">          0 :         R *= scale();</span>
<span class="lineNum">     214 </span><span class="lineNoCov">          0 :         w = A * wc + B * wc2 + R; wc2 = wc; wc = w;</span>
<span class="lineNum">     215 </span>            :         if (gradp) {
<span class="lineNum">     216 </span><span class="lineNoCov">          0 :           w = A * wrc + B * wrc2 + (n + 1) * R; wrc2 = wrc; wrc = w;</span>
<span class="lineNum">     217 </span><span class="lineNoCov">          0 :           w = A * wtc + B * wtc2 -  u*Ax * wc2; wtc2 = wtc; wtc = w;</span>
<span class="lineNum">     218 </span>            :         }
<span class="lineNum">     219 </span><span class="lineNoCov">          0 :         if (m) {</span>
<span class="lineNum">     220 </span><span class="lineNoCov">          0 :           R = c[0].Sv(k[0]);</span>
<span class="lineNum">     221 </span><span class="lineNoCov">          0 :           for (int l = 1; l &lt; L; ++l)</span>
<span class="lineNum">     222 </span><span class="lineNoCov">          0 :             R += c[l].Sv(k[l], n, m, f[l]);</span>
<span class="lineNum">     223 </span><span class="lineNoCov">          0 :           R *= scale();</span>
<span class="lineNum">     224 </span><span class="lineNoCov">          0 :           w = A * ws + B * ws2 + R; ws2 = ws; ws = w;</span>
<span class="lineNum">     225 </span>            :           if (gradp) {
<span class="lineNum">     226 </span><span class="lineNoCov">          0 :             w = A * wrs + B * wrs2 + (n + 1) * R; wrs2 = wrs; wrs = w;</span>
<span class="lineNum">     227 </span><span class="lineNoCov">          0 :             w = A * wts + B * wts2 -  u*Ax * ws2; wts2 = wts; wts = w;</span>
<span class="lineNum">     228 </span>            :           }
<span class="lineNum">     229 </span>            :         }
<span class="lineNum">     230 </span>            :       }
<span class="lineNum">     231 </span>            :       // Now Sc[m] = wc, Ss[m] = ws
<span class="lineNum">     232 </span>            :       // Sc'[m] = wtc, Ss'[m] = wtc
<span class="lineNum">     233 </span><span class="lineNoCov">          0 :       if (m) {</span>
<span class="lineNum">     234 </span>            :         real v, A, B;           // alpha[m], beta[m + 1]
<span class="lineNum">     235 </span>            :         switch (norm) {
<span class="lineNum">     236 </span><span class="lineNoCov">          0 :         case FULL:</span>
<span class="lineNum">     237 </span><span class="lineNoCov">          0 :           v = root[2] * root[2 * m + 3] / root[m + 1];</span>
<span class="lineNum">     238 </span><span class="lineNoCov">          0 :           A = cl * v * uq;</span>
<span class="lineNum">     239 </span><span class="lineNoCov">          0 :           B = - v * root[2 * m + 5] / (root[8] * root[m + 2]) * uq2;</span>
<span class="lineNum">     240 </span>            :           break;
<span class="lineNum">     241 </span><span class="lineNoCov">          0 :         case SCHMIDT:</span>
<span class="lineNum">     242 </span><span class="lineNoCov">          0 :           v = root[2] * root[2 * m + 1] / root[m + 1];</span>
<span class="lineNum">     243 </span><span class="lineNoCov">          0 :           A = cl * v * uq;</span>
<span class="lineNum">     244 </span><span class="lineNoCov">          0 :           B = - v * root[2 * m + 3] / (root[8] * root[m + 2]) * uq2;</span>
<span class="lineNum">     245 </span>            :           break;
<span class="lineNum">     246 </span>            :         default: break;       // To suppress warning message from Visual Studio
<span class="lineNum">     247 </span>            :         }
<span class="lineNum">     248 </span><span class="lineNoCov">          0 :         v = A * vc  + B * vc2  +  wc ; vc2  = vc ; vc  = v;</span>
<span class="lineNum">     249 </span><span class="lineNoCov">          0 :         v = A * vs  + B * vs2  +  ws ; vs2  = vs ; vs  = v;</span>
<span class="lineNum">     250 </span>            :         if (gradp) {
<span class="lineNum">     251 </span>            :           // Include the terms Sc[m] * P'[m,m](t) and Ss[m] * P'[m,m](t)
<span class="lineNum">     252 </span><span class="lineNoCov">          0 :           wtc += m * tu * wc; wts += m * tu * ws;</span>
<span class="lineNum">     253 </span><span class="lineNoCov">          0 :           v = A * vrc + B * vrc2 +  wrc; vrc2 = vrc; vrc = v;</span>
<span class="lineNum">     254 </span><span class="lineNoCov">          0 :           v = A * vrs + B * vrs2 +  wrs; vrs2 = vrs; vrs = v;</span>
<span class="lineNum">     255 </span><span class="lineNoCov">          0 :           v = A * vtc + B * vtc2 +  wtc; vtc2 = vtc; vtc = v;</span>
<span class="lineNum">     256 </span><span class="lineNoCov">          0 :           v = A * vts + B * vts2 +  wts; vts2 = vts; vts = v;</span>
<span class="lineNum">     257 </span><span class="lineNoCov">          0 :           v = A * vlc + B * vlc2 + m*ws; vlc2 = vlc; vlc = v;</span>
<span class="lineNum">     258 </span><span class="lineNoCov">          0 :           v = A * vls + B * vls2 - m*wc; vls2 = vls; vls = v;</span>
<span class="lineNum">     259 </span>            :         }
<span class="lineNum">     260 </span>            :       } else {
<span class="lineNum">     261 </span>            :         real A, B, qs;
<span class="lineNum">     262 </span>            :         switch (norm) {
<span class="lineNum">     263 </span><span class="lineNoCov">          0 :         case FULL:</span>
<span class="lineNum">     264 </span><span class="lineNoCov">          0 :           A = root[3] * uq;       // F[1]/(q*cl) or F[1]/(q*sl)</span>
<span class="lineNum">     265 </span><span class="lineNoCov">          0 :           B = - root[15]/2 * uq2; // beta[1]/q</span>
<span class="lineNum">     266 </span>            :           break;
<span class="lineNum">     267 </span><span class="lineNoCov">          0 :         case SCHMIDT:</span>
<span class="lineNum">     268 </span>            :           A = uq;
<span class="lineNum">     269 </span><span class="lineNoCov">          0 :           B = - root[3]/2 * uq2;</span>
<span class="lineNum">     270 </span>            :           break;
<span class="lineNum">     271 </span>            :         default: break;       // To suppress warning message from Visual Studio
<span class="lineNum">     272 </span>            :         }
<span class="lineNum">     273 </span><span class="lineNoCov">          0 :         qs = q / scale();</span>
<span class="lineNum">     274 </span><span class="lineNoCov">          0 :         vc = qs * (wc + A * (cl * vc + sl * vs ) + B * vc2);</span>
<span class="lineNum">     275 </span>            :         if (gradp) {
<span class="lineNum">     276 </span><span class="lineNoCov">          0 :           qs /= r;</span>
<span class="lineNum">     277 </span>            :           // The components of the gradient in spherical coordinates are
<span class="lineNum">     278 </span>            :           // r: dV/dr
<span class="lineNum">     279 </span>            :           // theta: 1/r * dV/dtheta
<span class="lineNum">     280 </span>            :           // lambda: 1/(r*u) * dV/dlambda
<span class="lineNum">     281 </span><span class="lineNoCov">          0 :           vrc =   - qs * (wrc + A * (cl * vrc + sl * vrs) + B * vrc2);</span>
<span class="lineNum">     282 </span><span class="lineNoCov">          0 :           vtc =     qs * (wtc + A * (cl * vtc + sl * vts) + B * vtc2);</span>
<span class="lineNum">     283 </span><span class="lineNoCov">          0 :           vlc = qs / u * (      A * (cl * vlc + sl * vls) + B * vlc2);</span>
<span class="lineNum">     284 </span>            :         }
<span class="lineNum">     285 </span>            :       }
<span class="lineNum">     286 </span>            :     }
<span class="lineNum">     287 </span>            : 
<span class="lineNum">     288 </span>            :     if (gradp) {
<span class="lineNum">     289 </span>            :       // Rotate into cartesian (geocentric) coordinates
<span class="lineNum">     290 </span><span class="lineNoCov">          0 :       gradx = cl * (u * vrc + t * vtc) - sl * vlc;</span>
<span class="lineNum">     291 </span><span class="lineNoCov">          0 :       grady = sl * (u * vrc + t * vtc) + cl * vlc;</span>
<span class="lineNum">     292 </span><span class="lineNoCov">          0 :       gradz =       t * vrc - u * vtc            ;</span>
<span class="lineNum">     293 </span>            :     }
<span class="lineNum">     294 </span><span class="lineNoCov">          0 :     return vc;</span>
<span class="lineNum">     295 </span>            :   }
<span class="lineNum">     296 </span>            : 
<span class="lineNum">     297 </span>            :   template&lt;bool gradp, SphericalEngine::normalization norm, int L&gt;
<span class="lineNum">     298 </span><span class="lineNoCov">          0 :   CircularEngine SphericalEngine::Circle(const coeff c[], const real f[],</span>
<span class="lineNum">     299 </span>            :                                          real p, real z, real a) {
<span class="lineNum">     300 </span>            : 
<span class="lineNum">     301 </span>            :     GEOGRAPHICLIB_STATIC_ASSERT(L &gt; 0, &quot;L must be positive&quot;);
<span class="lineNum">     302 </span>            :     GEOGRAPHICLIB_STATIC_ASSERT(norm == FULL || norm == SCHMIDT,
<span class="lineNum">     303 </span>            :                                 &quot;Unknown normalization&quot;);
<span class="lineNum">     304 </span><span class="lineNoCov">          0 :     int N = c[0].nmx(), M = c[0].mmx();</span>
<span class="lineNum">     305 </span>            : 
<span class="lineNum">     306 </span>            :     real
<span class="lineNum">     307 </span>            :       r = Math::hypot(z, p),
<span class="lineNum">     308 </span><span class="lineNoCov">          0 :       t = r != 0 ? z / r : 0,   // cos(theta); at origin, pick theta = pi/2</span>
<span class="lineNum">     309 </span><span class="lineNoCov">          0 :       u = r != 0 ? max(p / r, eps()) : 1, // sin(theta); but avoid the pole</span>
<span class="lineNum">     310 </span><span class="lineNoCov">          0 :       q = a / r;</span>
<span class="lineNum">     311 </span>            :     real
<span class="lineNum">     312 </span>            :       q2 = Math::sq(q),
<span class="lineNum">     313 </span><span class="lineNoCov">          0 :       tu = t / u;</span>
<span class="lineNum">     314 </span><span class="lineNoCov">          0 :     CircularEngine circ(M, gradp, norm, a, r, u, t);</span>
<span class="lineNum">     315 </span>            :     int k[L];
<span class="lineNum">     316 </span><span class="lineNoCov">          0 :     const vector&lt;real&gt;&amp; root( sqrttable() );</span>
<span class="lineNum">     317 </span><span class="lineNoCov">          0 :     for (int m = M; m &gt;= 0; --m) {   // m = M .. 0</span>
<span class="lineNum">     318 </span>            :       // Initialize inner sum
<span class="lineNum">     319 </span>            :       real
<span class="lineNum">     320 </span>            :         wc  = 0, wc2  = 0, ws  = 0, ws2  = 0, // w [N - m + 1], w [N - m + 2]
<span class="lineNum">     321 </span>            :         wrc = 0, wrc2 = 0, wrs = 0, wrs2 = 0, // wr[N - m + 1], wr[N - m + 2]
<span class="lineNum">     322 </span>            :         wtc = 0, wtc2 = 0, wts = 0, wts2 = 0; // wt[N - m + 1], wt[N - m + 2]
<span class="lineNum">     323 </span><span class="lineNoCov">          0 :       for (int l = 0; l &lt; L; ++l)</span>
<span class="lineNum">     324 </span><span class="lineNoCov">          0 :         k[l] = c[l].index(N, m) + 1;</span>
<span class="lineNum">     325 </span><span class="lineNoCov">          0 :       for (int n = N; n &gt;= m; --n) {             // n = N .. m; l = N - m .. 0</span>
<span class="lineNum">     326 </span>            :         real w, A, Ax, B, R;    // alpha[l], beta[l + 1]
<span class="lineNum">     327 </span>            :         switch (norm) {
<span class="lineNum">     328 </span><span class="lineNoCov">          0 :         case FULL:</span>
<span class="lineNum">     329 </span><span class="lineNoCov">          0 :           w = root[2 * n + 1] / (root[n - m + 1] * root[n + m + 1]);</span>
<span class="lineNum">     330 </span><span class="lineNoCov">          0 :           Ax = q * w * root[2 * n + 3];</span>
<span class="lineNum">     331 </span><span class="lineNoCov">          0 :           A = t * Ax;</span>
<span class="lineNum">     332 </span><span class="lineNoCov">          0 :           B = - q2 * root[2 * n + 5] /</span>
<span class="lineNum">     333 </span><span class="lineNoCov">          0 :             (w * root[n - m + 2] * root[n + m + 2]);</span>
<span class="lineNum">     334 </span>            :           break;
<span class="lineNum">     335 </span><span class="lineNoCov">          0 :         case SCHMIDT:</span>
<span class="lineNum">     336 </span><span class="lineNoCov">          0 :           w = root[n - m + 1] * root[n + m + 1];</span>
<span class="lineNum">     337 </span><span class="lineNoCov">          0 :           Ax = q * (2 * n + 1) / w;</span>
<span class="lineNum">     338 </span><span class="lineNoCov">          0 :           A = t * Ax;</span>
<span class="lineNum">     339 </span><span class="lineNoCov">          0 :           B = - q2 * w / (root[n - m + 2] * root[n + m + 2]);</span>
<span class="lineNum">     340 </span>            :           break;
<span class="lineNum">     341 </span>            :         default: break;       // To suppress warning message from Visual Studio
<span class="lineNum">     342 </span>            :         }
<span class="lineNum">     343 </span><span class="lineNoCov">          0 :         R = c[0].Cv(--k[0]);</span>
<span class="lineNum">     344 </span><span class="lineNoCov">          0 :         for (int l = 1; l &lt; L; ++l)</span>
<span class="lineNum">     345 </span><span class="lineNoCov">          0 :           R += c[l].Cv(--k[l], n, m, f[l]);</span>
<span class="lineNum">     346 </span><span class="lineNoCov">          0 :         R *= scale();</span>
<span class="lineNum">     347 </span><span class="lineNoCov">          0 :         w = A * wc + B * wc2 + R; wc2 = wc; wc = w;</span>
<span class="lineNum">     348 </span>            :         if (gradp) {
<span class="lineNum">     349 </span><span class="lineNoCov">          0 :           w = A * wrc + B * wrc2 + (n + 1) * R; wrc2 = wrc; wrc = w;</span>
<span class="lineNum">     350 </span><span class="lineNoCov">          0 :           w = A * wtc + B * wtc2 -  u*Ax * wc2; wtc2 = wtc; wtc = w;</span>
<span class="lineNum">     351 </span>            :         }
<span class="lineNum">     352 </span><span class="lineNoCov">          0 :         if (m) {</span>
<span class="lineNum">     353 </span><span class="lineNoCov">          0 :           R = c[0].Sv(k[0]);</span>
<span class="lineNum">     354 </span><span class="lineNoCov">          0 :           for (int l = 1; l &lt; L; ++l)</span>
<span class="lineNum">     355 </span><span class="lineNoCov">          0 :             R += c[l].Sv(k[l], n, m, f[l]);</span>
<span class="lineNum">     356 </span><span class="lineNoCov">          0 :           R *= scale();</span>
<span class="lineNum">     357 </span><span class="lineNoCov">          0 :           w = A * ws + B * ws2 + R; ws2 = ws; ws = w;</span>
<span class="lineNum">     358 </span>            :           if (gradp) {
<span class="lineNum">     359 </span><span class="lineNoCov">          0 :             w = A * wrs + B * wrs2 + (n + 1) * R; wrs2 = wrs; wrs = w;</span>
<span class="lineNum">     360 </span><span class="lineNoCov">          0 :             w = A * wts + B * wts2 -  u*Ax * ws2; wts2 = wts; wts = w;</span>
<span class="lineNum">     361 </span>            :           }
<span class="lineNum">     362 </span>            :         }
<span class="lineNum">     363 </span>            :       }
<span class="lineNum">     364 </span>            :       if (!gradp)
<span class="lineNum">     365 </span>            :         circ.SetCoeff(m, wc, ws);
<span class="lineNum">     366 </span>            :       else {
<span class="lineNum">     367 </span>            :         // Include the terms Sc[m] * P'[m,m](t) and  Ss[m] * P'[m,m](t)
<span class="lineNum">     368 </span><span class="lineNoCov">          0 :         wtc += m * tu * wc; wts += m * tu * ws;</span>
<span class="lineNum">     369 </span>            :         circ.SetCoeff(m, wc, ws, wrc, wrs, wtc, wts);
<span class="lineNum">     370 </span>            :       }
<span class="lineNum">     371 </span>            :     }
<span class="lineNum">     372 </span>            : 
<span class="lineNum">     373 </span><span class="lineNoCov">          0 :     return circ;</span>
<span class="lineNum">     374 </span>            :   }
<span class="lineNum">     375 </span>            : 
<span class="lineNum">     376 </span><span class="lineNoCov">          0 :   void SphericalEngine::RootTable(int N) {</span>
<span class="lineNum">     377 </span>            :     // Need square roots up to max(2 * N + 5, 15).
<span class="lineNum">     378 </span><span class="lineNoCov">          0 :     vector&lt;real&gt;&amp; root( sqrttable() );</span>
<span class="lineNum">     379 </span><span class="lineNoCov">          0 :     int L = max(2 * N + 5, 15) + 1, oldL = int(root.size());</span>
<span class="lineNum">     380 </span><span class="lineNoCov">          0 :     if (oldL &gt;= L)</span>
<span class="lineNum">     381 </span>            :       return;
<span class="lineNum">     382 </span><span class="lineNoCov">          0 :     root.resize(L);</span>
<span class="lineNum">     383 </span><span class="lineNoCov">          0 :     for (int l = oldL; l &lt; L; ++l)</span>
<span class="lineNum">     384 </span><span class="lineNoCov">          0 :       root[l] = sqrt(real(l));</span>
<span class="lineNum">     385 </span>            :   }
<span class="lineNum">     386 </span>            : 
<span class="lineNum">     387 </span><span class="lineNoCov">          0 :   void SphericalEngine::coeff::readcoeffs(std::istream&amp; stream, int&amp; N, int&amp; M,</span>
<span class="lineNum">     388 </span>            :                                           std::vector&lt;real&gt;&amp; C,
<span class="lineNum">     389 </span>            :                                           std::vector&lt;real&gt;&amp; S) {
<span class="lineNum">     390 </span>            :     int nm[2];
<span class="lineNum">     391 </span><span class="lineNoCov">          0 :     Utility::readarray&lt;int, int, false&gt;(stream, nm, 2);</span>
<span class="lineNum">     392 </span><span class="lineNoCov">          0 :     N = nm[0]; M = nm[1];</span>
<span class="lineNum">     393 </span><span class="lineNoCov">          0 :     if (!(N &gt;= M &amp;&amp; M &gt;= -1 &amp;&amp; N * M &gt;= 0))</span>
<span class="lineNum">     394 </span>            :       // The last condition is that M = -1 implies N = -1 and vice versa.
<span class="lineNum">     395 </span><span class="lineNoCov">          0 :       throw GeographicErr(&quot;Bad degree and order &quot; +</span>
<span class="lineNum">     396 </span><span class="lineNoCov">          0 :                           Utility::str(N) + &quot; &quot; + Utility::str(M));</span>
<span class="lineNum">     397 </span><span class="lineNoCov">          0 :     C.resize(SphericalEngine::coeff::Csize(N, M));</span>
<span class="lineNum">     398 </span>            :     Utility::readarray&lt;double, real, false&gt;(stream, C);
<span class="lineNum">     399 </span><span class="lineNoCov">          0 :     S.resize(SphericalEngine::coeff::Ssize(N, M));</span>
<span class="lineNum">     400 </span>            :     Utility::readarray&lt;double, real, false&gt;(stream, S);
<span class="lineNum">     401 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">     402 </span>            :   }
<span class="lineNum">     403 </span>            : 
<span class="lineNum">     404 </span>            :   /// \cond SKIP
<span class="lineNum">     405 </span>            :   template Math::real GEOGRAPHICLIB_EXPORT
<span class="lineNum">     406 </span>            :   SphericalEngine::Value&lt;true, SphericalEngine::FULL, 1&gt;
<span class="lineNum">     407 </span>            :   (const coeff[], const real[], real, real, real, real, real&amp;, real&amp;, real&amp;);
<span class="lineNum">     408 </span>            :   template Math::real GEOGRAPHICLIB_EXPORT
<span class="lineNum">     409 </span>            :   SphericalEngine::Value&lt;false, SphericalEngine::FULL, 1&gt;
<span class="lineNum">     410 </span>            :   (const coeff[], const real[], real, real, real, real, real&amp;, real&amp;, real&amp;);
<span class="lineNum">     411 </span>            :   template Math::real GEOGRAPHICLIB_EXPORT
<span class="lineNum">     412 </span>            :   SphericalEngine::Value&lt;true, SphericalEngine::SCHMIDT, 1&gt;
<span class="lineNum">     413 </span>            :   (const coeff[], const real[], real, real, real, real, real&amp;, real&amp;, real&amp;);
<span class="lineNum">     414 </span>            :   template Math::real GEOGRAPHICLIB_EXPORT
<span class="lineNum">     415 </span>            :   SphericalEngine::Value&lt;false, SphericalEngine::SCHMIDT, 1&gt;
<span class="lineNum">     416 </span>            :   (const coeff[], const real[], real, real, real, real, real&amp;, real&amp;, real&amp;);
<span class="lineNum">     417 </span>            : 
<span class="lineNum">     418 </span>            :   template Math::real GEOGRAPHICLIB_EXPORT
<span class="lineNum">     419 </span>            :   SphericalEngine::Value&lt;true, SphericalEngine::FULL, 2&gt;
<span class="lineNum">     420 </span>            :   (const coeff[], const real[], real, real, real, real, real&amp;, real&amp;, real&amp;);
<span class="lineNum">     421 </span>            :   template Math::real GEOGRAPHICLIB_EXPORT
<span class="lineNum">     422 </span>            :   SphericalEngine::Value&lt;false, SphericalEngine::FULL, 2&gt;
<span class="lineNum">     423 </span>            :   (const coeff[], const real[], real, real, real, real, real&amp;, real&amp;, real&amp;);
<span class="lineNum">     424 </span>            :   template Math::real GEOGRAPHICLIB_EXPORT
<span class="lineNum">     425 </span>            :   SphericalEngine::Value&lt;true, SphericalEngine::SCHMIDT, 2&gt;
<span class="lineNum">     426 </span>            :   (const coeff[], const real[], real, real, real, real, real&amp;, real&amp;, real&amp;);
<span class="lineNum">     427 </span>            :   template Math::real GEOGRAPHICLIB_EXPORT
<span class="lineNum">     428 </span>            :   SphericalEngine::Value&lt;false, SphericalEngine::SCHMIDT, 2&gt;
<span class="lineNum">     429 </span>            :   (const coeff[], const real[], real, real, real, real, real&amp;, real&amp;, real&amp;);
<span class="lineNum">     430 </span>            : 
<span class="lineNum">     431 </span>            :   template Math::real GEOGRAPHICLIB_EXPORT
<span class="lineNum">     432 </span>            :   SphericalEngine::Value&lt;true, SphericalEngine::FULL, 3&gt;
<span class="lineNum">     433 </span>            :   (const coeff[], const real[], real, real, real, real, real&amp;, real&amp;, real&amp;);
<span class="lineNum">     434 </span>            :   template Math::real GEOGRAPHICLIB_EXPORT
<span class="lineNum">     435 </span>            :   SphericalEngine::Value&lt;false, SphericalEngine::FULL, 3&gt;
<span class="lineNum">     436 </span>            :   (const coeff[], const real[], real, real, real, real, real&amp;, real&amp;, real&amp;);
<span class="lineNum">     437 </span>            :   template Math::real GEOGRAPHICLIB_EXPORT
<span class="lineNum">     438 </span>            :   SphericalEngine::Value&lt;true, SphericalEngine::SCHMIDT, 3&gt;
<span class="lineNum">     439 </span>            :   (const coeff[], const real[], real, real, real, real, real&amp;, real&amp;, real&amp;);
<span class="lineNum">     440 </span>            :   template Math::real GEOGRAPHICLIB_EXPORT
<span class="lineNum">     441 </span>            :   SphericalEngine::Value&lt;false, SphericalEngine::SCHMIDT, 3&gt;
<span class="lineNum">     442 </span>            :   (const coeff[], const real[], real, real, real, real, real&amp;, real&amp;, real&amp;);
<span class="lineNum">     443 </span>            : 
<span class="lineNum">     444 </span>            :   template CircularEngine GEOGRAPHICLIB_EXPORT
<span class="lineNum">     445 </span>            :   SphericalEngine::Circle&lt;true, SphericalEngine::FULL, 1&gt;
<span class="lineNum">     446 </span>            :   (const coeff[], const real[], real, real, real);
<span class="lineNum">     447 </span>            :   template CircularEngine GEOGRAPHICLIB_EXPORT
<span class="lineNum">     448 </span>            :   SphericalEngine::Circle&lt;false, SphericalEngine::FULL, 1&gt;
<span class="lineNum">     449 </span>            :   (const coeff[], const real[], real, real, real);
<span class="lineNum">     450 </span>            :   template CircularEngine GEOGRAPHICLIB_EXPORT
<span class="lineNum">     451 </span>            :   SphericalEngine::Circle&lt;true, SphericalEngine::SCHMIDT, 1&gt;
<span class="lineNum">     452 </span>            :   (const coeff[], const real[], real, real, real);
<span class="lineNum">     453 </span>            :   template CircularEngine GEOGRAPHICLIB_EXPORT
<span class="lineNum">     454 </span>            :   SphericalEngine::Circle&lt;false, SphericalEngine::SCHMIDT, 1&gt;
<span class="lineNum">     455 </span>            :   (const coeff[], const real[], real, real, real);
<span class="lineNum">     456 </span>            : 
<span class="lineNum">     457 </span>            :   template CircularEngine GEOGRAPHICLIB_EXPORT
<span class="lineNum">     458 </span>            :   SphericalEngine::Circle&lt;true, SphericalEngine::FULL, 2&gt;
<span class="lineNum">     459 </span>            :   (const coeff[], const real[], real, real, real);
<span class="lineNum">     460 </span>            :   template CircularEngine GEOGRAPHICLIB_EXPORT
<span class="lineNum">     461 </span>            :   SphericalEngine::Circle&lt;false, SphericalEngine::FULL, 2&gt;
<span class="lineNum">     462 </span>            :   (const coeff[], const real[], real, real, real);
<span class="lineNum">     463 </span>            :   template CircularEngine GEOGRAPHICLIB_EXPORT
<span class="lineNum">     464 </span>            :   SphericalEngine::Circle&lt;true, SphericalEngine::SCHMIDT, 2&gt;
<span class="lineNum">     465 </span>            :   (const coeff[], const real[], real, real, real);
<span class="lineNum">     466 </span>            :   template CircularEngine GEOGRAPHICLIB_EXPORT
<span class="lineNum">     467 </span>            :   SphericalEngine::Circle&lt;false, SphericalEngine::SCHMIDT, 2&gt;
<span class="lineNum">     468 </span>            :   (const coeff[], const real[], real, real, real);
<span class="lineNum">     469 </span>            : 
<span class="lineNum">     470 </span>            :   template CircularEngine GEOGRAPHICLIB_EXPORT
<span class="lineNum">     471 </span>            :   SphericalEngine::Circle&lt;true, SphericalEngine::FULL, 3&gt;
<span class="lineNum">     472 </span>            :   (const coeff[], const real[], real, real, real);
<span class="lineNum">     473 </span>            :   template CircularEngine GEOGRAPHICLIB_EXPORT
<span class="lineNum">     474 </span>            :   SphericalEngine::Circle&lt;false, SphericalEngine::FULL, 3&gt;
<span class="lineNum">     475 </span>            :   (const coeff[], const real[], real, real, real);
<span class="lineNum">     476 </span>            :   template CircularEngine GEOGRAPHICLIB_EXPORT
<span class="lineNum">     477 </span>            :   SphericalEngine::Circle&lt;true, SphericalEngine::SCHMIDT, 3&gt;
<span class="lineNum">     478 </span>            :   (const coeff[], const real[], real, real, real);
<span class="lineNum">     479 </span>            :   template CircularEngine GEOGRAPHICLIB_EXPORT
<span class="lineNum">     480 </span>            :   SphericalEngine::Circle&lt;false, SphericalEngine::SCHMIDT, 3&gt;
<span class="lineNum">     481 </span>            :   (const coeff[], const real[], real, real, real);
<span class="lineNum">     482 </span>            :   /// \endcond
<span class="lineNum">     483 </span>            : 
<span class="lineNum">     484 </span>            : } // namespace GeographicLib
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>

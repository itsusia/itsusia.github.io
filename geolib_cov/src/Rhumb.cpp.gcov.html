<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - main_coverage.info - src/Rhumb.cpp</title>
  <link rel="stylesheet" type="text/css" href="../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../index.html">top level</a> - <a href="index.html">src</a> - Rhumb.cpp<span style="font-size: 80%;"> (source / <a href="Rhumb.cpp.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">main_coverage.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">90</td>
            <td class="headerCovTableEntry">131</td>
            <td class="headerCovTableEntryLo">68.7 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2019-11-14 17:15:21</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">11</td>
            <td class="headerCovTableEntry">16</td>
            <td class="headerCovTableEntryLo">68.8 %</td>
          </tr>
          <tr><td><img src="../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /**</a>
<span class="lineNum">       2 </span>            :  * \file Rhumb.cpp
<span class="lineNum">       3 </span>            :  * \brief Implementation for GeographicLib::Rhumb and GeographicLib::RhumbLine
<span class="lineNum">       4 </span>            :  * classes
<span class="lineNum">       5 </span>            :  *
<span class="lineNum">       6 </span>            :  * Copyright (c) Charles Karney (2014-2017) &lt;charles@karney.com&gt; and licensed
<span class="lineNum">       7 </span>            :  * under the MIT/X11 License.  For more information, see
<span class="lineNum">       8 </span>            :  * https://geographiclib.sourceforge.io/
<span class="lineNum">       9 </span>            :  **********************************************************************/
<span class="lineNum">      10 </span>            : 
<span class="lineNum">      11 </span>            : #include &lt;algorithm&gt;
<span class="lineNum">      12 </span>            : #include &lt;GeographicLib/Rhumb.hpp&gt;
<span class="lineNum">      13 </span>            : 
<span class="lineNum">      14 </span>            : namespace GeographicLib {
<span class="lineNum">      15 </span>            : 
<a name="16"><span class="lineNum">      16 </span>            :   using namespace std;</a>
<span class="lineNum">      17 </span>            : 
<span class="lineNum">      18 </span><span class="lineCov">         17 :   Rhumb::Rhumb(real a, real f, bool exact)</span>
<span class="lineNum">      19 </span>            :     : _ell(a, f)
<span class="lineNum">      20 </span>            :     , _exact(exact)
<span class="lineNum">      21 </span><span class="lineCov">         17 :     , _c2(_ell.Area() / 720)</span>
<span class="lineNum">      22 </span>            :   {
<span class="lineNum">      23 </span>            :     // Generated by Maxima on 2015-05-15 08:24:04-04:00
<span class="lineNum">      24 </span>            : #if GEOGRAPHICLIB_RHUMBAREA_ORDER == 4
<span class="lineNum">      25 </span>            :     static const real coeff[] = {
<span class="lineNum">      26 </span>            :       // R[0]/n^0, polynomial in n of order 4
<span class="lineNum">      27 </span>            :       691, 7860, -20160, 18900, 0, 56700,
<span class="lineNum">      28 </span>            :       // R[1]/n^1, polynomial in n of order 3
<span class="lineNum">      29 </span>            :       1772, -5340, 6930, -4725, 14175,
<span class="lineNum">      30 </span>            :       // R[2]/n^2, polynomial in n of order 2
<span class="lineNum">      31 </span>            :       -1747, 1590, -630, 4725,
<span class="lineNum">      32 </span>            :       // R[3]/n^3, polynomial in n of order 1
<span class="lineNum">      33 </span>            :       104, -31, 315,
<span class="lineNum">      34 </span>            :       // R[4]/n^4, polynomial in n of order 0
<span class="lineNum">      35 </span>            :       -41, 420,
<span class="lineNum">      36 </span>            :     };  // count = 20
<span class="lineNum">      37 </span>            : #elif GEOGRAPHICLIB_RHUMBAREA_ORDER == 5
<span class="lineNum">      38 </span>            :     static const real coeff[] = {
<span class="lineNum">      39 </span>            :       // R[0]/n^0, polynomial in n of order 5
<span class="lineNum">      40 </span>            :       -79036, 22803, 259380, -665280, 623700, 0, 1871100,
<span class="lineNum">      41 </span>            :       // R[1]/n^1, polynomial in n of order 4
<span class="lineNum">      42 </span>            :       41662, 58476, -176220, 228690, -155925, 467775,
<span class="lineNum">      43 </span>            :       // R[2]/n^2, polynomial in n of order 3
<span class="lineNum">      44 </span>            :       18118, -57651, 52470, -20790, 155925,
<span class="lineNum">      45 </span>            :       // R[3]/n^3, polynomial in n of order 2
<span class="lineNum">      46 </span>            :       -23011, 17160, -5115, 51975,
<span class="lineNum">      47 </span>            :       // R[4]/n^4, polynomial in n of order 1
<span class="lineNum">      48 </span>            :       5480, -1353, 13860,
<span class="lineNum">      49 </span>            :       // R[5]/n^5, polynomial in n of order 0
<span class="lineNum">      50 </span>            :       -668, 5775,
<span class="lineNum">      51 </span>            :     };  // count = 27
<span class="lineNum">      52 </span>            : #elif GEOGRAPHICLIB_RHUMBAREA_ORDER == 6
<span class="lineNum">      53 </span>            :     static const real coeff[] = {
<span class="lineNum">      54 </span>            :       // R[0]/n^0, polynomial in n of order 6
<span class="lineNum">      55 </span>            :       128346268, -107884140, 31126095, 354053700, -908107200, 851350500, 0,
<span class="lineNum">      56 </span>            :       2554051500LL,
<span class="lineNum">      57 </span>            :       // R[1]/n^1, polynomial in n of order 5
<span class="lineNum">      58 </span>            :       -114456994, 56868630, 79819740, -240540300, 312161850, -212837625,
<span class="lineNum">      59 </span>            :       638512875,
<span class="lineNum">      60 </span>            :       // R[2]/n^2, polynomial in n of order 4
<span class="lineNum">      61 </span>            :       51304574, 24731070, -78693615, 71621550, -28378350, 212837625,
<span class="lineNum">      62 </span>            :       // R[3]/n^3, polynomial in n of order 3
<span class="lineNum">      63 </span>            :       1554472, -6282003, 4684680, -1396395, 14189175,
<span class="lineNum">      64 </span>            :       // R[4]/n^4, polynomial in n of order 2
<span class="lineNum">      65 </span>            :       -4913956, 3205800, -791505, 8108100,
<span class="lineNum">      66 </span>            :       // R[5]/n^5, polynomial in n of order 1
<span class="lineNum">      67 </span>            :       1092376, -234468, 2027025,
<span class="lineNum">      68 </span>            :       // R[6]/n^6, polynomial in n of order 0
<span class="lineNum">      69 </span>            :       -313076, 2027025,
<span class="lineNum">      70 </span>            :     };  // count = 35
<span class="lineNum">      71 </span>            : #elif GEOGRAPHICLIB_RHUMBAREA_ORDER == 7
<span class="lineNum">      72 </span>            :     static const real coeff[] = {
<span class="lineNum">      73 </span>            :       // R[0]/n^0, polynomial in n of order 7
<span class="lineNum">      74 </span>            :       -317195588, 385038804, -323652420, 93378285, 1062161100, -2724321600LL,
<span class="lineNum">      75 </span>            :       2554051500LL, 0, 7662154500LL,
<span class="lineNum">      76 </span>            :       // R[1]/n^1, polynomial in n of order 6
<span class="lineNum">      77 </span>            :       258618446, -343370982, 170605890, 239459220, -721620900, 936485550,
<span class="lineNum">      78 </span>            :       -638512875, 1915538625,
<span class="lineNum">      79 </span>            :       // R[2]/n^2, polynomial in n of order 5
<span class="lineNum">      80 </span>            :       -248174686, 153913722, 74193210, -236080845, 214864650, -85135050,
<span class="lineNum">      81 </span>            :       638512875,
<span class="lineNum">      82 </span>            :       // R[3]/n^3, polynomial in n of order 4
<span class="lineNum">      83 </span>            :       114450437, 23317080, -94230045, 70270200, -20945925, 212837625,
<span class="lineNum">      84 </span>            :       // R[4]/n^4, polynomial in n of order 3
<span class="lineNum">      85 </span>            :       15445736, -103193076, 67321800, -16621605, 170270100,
<span class="lineNum">      86 </span>            :       // R[5]/n^5, polynomial in n of order 2
<span class="lineNum">      87 </span>            :       -27766753, 16385640, -3517020, 30405375,
<span class="lineNum">      88 </span>            :       // R[6]/n^6, polynomial in n of order 1
<span class="lineNum">      89 </span>            :       4892722, -939228, 6081075,
<span class="lineNum">      90 </span>            :       // R[7]/n^7, polynomial in n of order 0
<span class="lineNum">      91 </span>            :       -3189007, 14189175,
<span class="lineNum">      92 </span>            :     };  // count = 44
<span class="lineNum">      93 </span>            : #elif GEOGRAPHICLIB_RHUMBAREA_ORDER == 8
<span class="lineNum">      94 </span>            :     static const real coeff[] = {
<span class="lineNum">      95 </span>            :       // R[0]/n^0, polynomial in n of order 8
<span class="lineNum">      96 </span>            :       71374704821LL, -161769749880LL, 196369790040LL, -165062734200LL,
<span class="lineNum">      97 </span>            :       47622925350LL, 541702161000LL, -1389404016000LL, 1302566265000LL, 0,
<span class="lineNum">      98 </span>            :       3907698795000LL,
<span class="lineNum">      99 </span>            :       // R[1]/n^1, polynomial in n of order 7
<span class="lineNum">     100 </span>            :       -13691187484LL, 65947703730LL, -87559600410LL, 43504501950LL,
<span class="lineNum">     101 </span>            :       61062101100LL, -184013329500LL, 238803815250LL, -162820783125LL,
<span class="lineNum">     102 </span>            :       488462349375LL,
<span class="lineNum">     103 </span>            :       // R[2]/n^2, polynomial in n of order 6
<span class="lineNum">     104 </span>            :       30802104839LL, -63284544930LL, 39247999110LL, 18919268550LL,
<span class="lineNum">     105 </span>            :       -60200615475LL, 54790485750LL, -21709437750LL, 162820783125LL,
<span class="lineNum">     106 </span>            :       // R[3]/n^3, polynomial in n of order 5
<span class="lineNum">     107 </span>            :       -8934064508LL, 5836972287LL, 1189171080, -4805732295LL, 3583780200LL,
<span class="lineNum">     108 </span>            :       -1068242175, 10854718875LL,
<span class="lineNum">     109 </span>            :       // R[4]/n^4, polynomial in n of order 4
<span class="lineNum">     110 </span>            :       50072287748LL, 3938662680LL, -26314234380LL, 17167059000LL,
<span class="lineNum">     111 </span>            :       -4238509275LL, 43418875500LL,
<span class="lineNum">     112 </span>            :       // R[5]/n^5, polynomial in n of order 3
<span class="lineNum">     113 </span>            :       359094172, -9912730821LL, 5849673480LL, -1255576140, 10854718875LL,
<span class="lineNum">     114 </span>            :       // R[6]/n^6, polynomial in n of order 2
<span class="lineNum">     115 </span>            :       -16053944387LL, 8733508770LL, -1676521980, 10854718875LL,
<span class="lineNum">     116 </span>            :       // R[7]/n^7, polynomial in n of order 1
<span class="lineNum">     117 </span>            :       930092876, -162639357, 723647925,
<span class="lineNum">     118 </span>            :       // R[8]/n^8, polynomial in n of order 0
<span class="lineNum">     119 </span>            :       -673429061, 1929727800,
<span class="lineNum">     120 </span>            :     };  // count = 54
<span class="lineNum">     121 </span>            : #else
<span class="lineNum">     122 </span>            : #error &quot;Bad value for GEOGRAPHICLIB_RHUMBAREA_ORDER&quot;
<span class="lineNum">     123 </span>            : #endif
<span class="lineNum">     124 </span>            :     GEOGRAPHICLIB_STATIC_ASSERT(sizeof(coeff) / sizeof(real) ==
<span class="lineNum">     125 </span>            :                                 ((maxpow_ + 1) * (maxpow_ + 4))/2,
<span class="lineNum">     126 </span>            :                                 &quot;Coefficient array size mismatch for Rhumb&quot;);
<span class="lineNum">     127 </span>            :     real d = 1;
<span class="lineNum">     128 </span>            :     int o = 0;
<span class="lineNum">     129 </span><span class="lineCov">        255 :     for (int l = 0; l &lt;= maxpow_; ++l) {</span>
<span class="lineNum">     130 </span><span class="lineCov">        119 :       int m = maxpow_ - l;</span>
<span class="lineNum">     131 </span>            :       // R[0] is just an integration constant so it cancels when evaluating a
<span class="lineNum">     132 </span>            :       // definite integral.  So don't bother computing it.  It won't be used
<span class="lineNum">     133 </span>            :       // when invoking SinCosSeries.
<span class="lineNum">     134 </span><span class="lineCov">        119 :       if (l)</span>
<span class="lineNum">     135 </span><span class="lineCov">        204 :         _R[l] = d * Math::polyval(m, coeff + o, _ell._n) / coeff[o + m + 1];</span>
<span class="lineNum">     136 </span><span class="lineCov">        119 :       o += m + 2;</span>
<span class="lineNum">     137 </span><span class="lineCov">        119 :       d *= _ell._n;</span>
<span class="lineNum">     138 </span>            :     }
<span class="lineNum">     139 </span>            :     // Post condition: o == sizeof(alpcoeff) / sizeof(real)
<a name="140"><span class="lineNum">     140 </span><span class="lineCov">         17 :   }</span></a>
<span class="lineNum">     141 </span>            : 
<span class="lineNum">     142 </span><span class="lineNoCov">          0 :   const Rhumb&amp; Rhumb::WGS84() {</span>
<span class="lineNum">     143 </span>            :     static const Rhumb
<span class="lineNum">     144 </span><span class="lineNoCov">          0 :       wgs84(Constants::WGS84_a(), Constants::WGS84_f(), false);</span>
<span class="lineNum">     145 </span><span class="lineNoCov">          0 :     return wgs84;</span>
<a name="146"><span class="lineNum">     146 </span>            :   }</a>
<span class="lineNum">     147 </span>            : 
<span class="lineNum">     148 </span><span class="lineCov">          8 :   void Rhumb::GenInverse(real lat1, real lon1, real lat2, real lon2,</span>
<span class="lineNum">     149 </span>            :                          unsigned outmask,
<span class="lineNum">     150 </span>            :                          real&amp; s12, real&amp; azi12, real&amp; S12) const {
<span class="lineNum">     151 </span>            :     real
<span class="lineNum">     152 </span>            :       lon12 = Math::AngDiff(lon1, lon2),
<span class="lineNum">     153 </span><span class="lineCov">          8 :       psi1 = _ell.IsometricLatitude(lat1),</span>
<span class="lineNum">     154 </span><span class="lineCov">          8 :       psi2 = _ell.IsometricLatitude(lat2),</span>
<span class="lineNum">     155 </span><span class="lineCov">          8 :       psi12 = psi2 - psi1,</span>
<span class="lineNum">     156 </span>            :       h = Math::hypot(lon12, psi12);
<span class="lineNum">     157 </span><span class="lineCov">          8 :     if (outmask &amp; AZIMUTH)</span>
<span class="lineNum">     158 </span><span class="lineCov">          2 :       azi12 = Math::atan2d(lon12, psi12);</span>
<span class="lineNum">     159 </span><span class="lineCov">          8 :     if (outmask &amp; DISTANCE) {</span>
<span class="lineNum">     160 </span><span class="lineCov">          8 :       real dmudpsi = DIsometricToRectifying(psi2, psi1);</span>
<span class="lineNum">     161 </span><span class="lineCov">          8 :       s12 = h * dmudpsi * _ell.QuarterMeridian() / 90;</span>
<span class="lineNum">     162 </span>            :     }
<span class="lineNum">     163 </span><span class="lineCov">          8 :     if (outmask &amp; AREA)</span>
<span class="lineNum">     164 </span><span class="lineCov">         16 :       S12 = _c2 * lon12 *</span>
<span class="lineNum">     165 </span><span class="lineCov">         16 :         MeanSinXi(psi2 * Math::degree(), psi1 * Math::degree());</span>
<a name="166"><span class="lineNum">     166 </span><span class="lineCov">          8 :   }</span></a>
<span class="lineNum">     167 </span>            : 
<span class="lineNum">     168 </span><span class="lineCov">          2 :   RhumbLine Rhumb::Line(real lat1, real lon1, real azi12) const</span>
<a name="169"><span class="lineNum">     169 </span><span class="lineCov">          2 :   { return RhumbLine(*this, lat1, lon1, azi12, _exact); }</span></a>
<span class="lineNum">     170 </span>            : 
<span class="lineNum">     171 </span><span class="lineNoCov">          0 :   void Rhumb::GenDirect(real lat1, real lon1, real azi12, real s12,</span>
<span class="lineNum">     172 </span>            :                         unsigned outmask,
<span class="lineNum">     173 </span>            :                         real&amp; lat2, real&amp; lon2, real&amp; S12) const
<a name="174"><span class="lineNum">     174 </span><span class="lineNoCov">          0 :   { Line(lat1, lon1, azi12).GenPosition(s12, outmask, lat2, lon2, S12); }</span></a>
<span class="lineNum">     175 </span>            : 
<span class="lineNum">     176 </span><span class="lineCov">          7 :   Math::real Rhumb::DE(real x, real y) const {</span>
<span class="lineNum">     177 </span><span class="lineCov">          7 :     const EllipticFunction&amp; ei = _ell._ell;</span>
<span class="lineNum">     178 </span><span class="lineCov">          7 :     real d = x - y;</span>
<span class="lineNum">     179 </span><span class="lineCov">          7 :     if (x * y &lt;= 0)</span>
<span class="lineNum">     180 </span><span class="lineCov">          1 :       return d != 0 ? (ei.E(x) - ei.E(y)) / d : 1;</span>
<span class="lineNum">     181 </span>            :     // See DLMF: Eqs (19.11.2) and (19.11.4) letting
<span class="lineNum">     182 </span>            :     // theta -&gt; x, phi -&gt; -y, psi -&gt; z
<span class="lineNum">     183 </span>            :     //
<span class="lineNum">     184 </span>            :     // (E(x) - E(y)) / d = E(z)/d - k2 * sin(x) * sin(y) * sin(z)/d
<span class="lineNum">     185 </span>            :     //
<span class="lineNum">     186 </span>            :     // tan(z/2) = (sin(x)*Delta(y) - sin(y)*Delta(x)) / (cos(x) + cos(y))
<span class="lineNum">     187 </span>            :     //          = d * Dsin(x,y) * (sin(x) + sin(y))/(cos(x) + cos(y)) /
<span class="lineNum">     188 </span>            :     //             (sin(x)*Delta(y) + sin(y)*Delta(x))
<span class="lineNum">     189 </span>            :     //          = t = d * Dt
<span class="lineNum">     190 </span>            :     // sin(z) = 2*t/(1+t^2); cos(z) = (1-t^2)/(1+t^2)
<span class="lineNum">     191 </span>            :     // Alt (this only works for |z| &lt;= pi/2 -- however, this conditions holds
<span class="lineNum">     192 </span>            :     // if x*y &gt; 0):
<span class="lineNum">     193 </span>            :     // sin(z) = d * Dsin(x,y) * (sin(x) + sin(y))/
<span class="lineNum">     194 </span>            :     //          (sin(x)*cos(y)*Delta(y) + sin(y)*cos(x)*Delta(x))
<span class="lineNum">     195 </span>            :     // cos(z) = sqrt((1-sin(z))*(1+sin(z)))
<span class="lineNum">     196 </span><span class="lineCov">          6 :     real sx = sin(x), sy = sin(y), cx = cos(x), cy = cos(y);</span>
<span class="lineNum">     197 </span><span class="lineCov">          6 :     real Dt = Dsin(x, y) * (sx + sy) /</span>
<span class="lineNum">     198 </span><span class="lineCov">         18 :       ((cx + cy) * (sx * ei.Delta(sy, cy) + sy * ei.Delta(sx, cx))),</span>
<span class="lineNum">     199 </span><span class="lineCov">          6 :       t = d * Dt, Dsz = 2 * Dt / (1 + t*t),</span>
<span class="lineNum">     200 </span><span class="lineCov">          6 :       sz = d * Dsz, cz = (1 - t) * (1 + t) / (1 + t*t);</span>
<span class="lineNum">     201 </span><span class="lineCov">          8 :     return ((sz != 0 ? ei.E(sz, cz, ei.Delta(sz, cz)) / sz : 1)</span>
<span class="lineNum">     202 </span><span class="lineCov">          6 :             - ei.k2() * sx * sy) * Dsz;</span>
<a name="203"><span class="lineNum">     203 </span>            :   }</a>
<span class="lineNum">     204 </span>            : 
<span class="lineNum">     205 </span><span class="lineCov">          7 :   Math::real Rhumb::DRectifying(real latx, real laty) const {</span>
<span class="lineNum">     206 </span>            :     real
<span class="lineNum">     207 </span><span class="lineCov">          7 :       tbetx = _ell._f1 * Math::tand(latx),</span>
<span class="lineNum">     208 </span><span class="lineCov">          7 :       tbety = _ell._f1 * Math::tand(laty);</span>
<span class="lineNum">     209 </span><span class="lineCov">          7 :     return (Math::pi()/2) * _ell._b * _ell._f1 * DE(atan(tbetx), atan(tbety))</span>
<span class="lineNum">     210 </span><span class="lineCov">          7 :       * Dtan(latx, laty) * Datan(tbetx, tbety) / _ell.QuarterMeridian();</span>
<a name="211"><span class="lineNum">     211 </span>            :   }</a>
<span class="lineNum">     212 </span>            : 
<span class="lineNum">     213 </span><span class="lineCov">          7 :   Math::real Rhumb::DIsometric(real latx, real laty) const {</span>
<span class="lineNum">     214 </span>            :     real
<span class="lineNum">     215 </span><span class="lineCov">          7 :       phix = latx * Math::degree(), tx = Math::tand(latx),</span>
<span class="lineNum">     216 </span><span class="lineCov">          7 :       phiy = laty * Math::degree(), ty = Math::tand(laty);</span>
<span class="lineNum">     217 </span><span class="lineCov">          7 :     return Dasinh(tx, ty) * Dtan(latx, laty)</span>
<span class="lineNum">     218 </span><span class="lineCov">          7 :       - Deatanhe(sin(phix), sin(phiy)) * Dsin(phix, phiy);</span>
<a name="219"><span class="lineNum">     219 </span>            :   }</a>
<span class="lineNum">     220 </span>            : 
<span class="lineNum">     221 </span><span class="lineCov">          9 :   Math::real Rhumb::SinCosSeries(bool sinp,</span>
<span class="lineNum">     222 </span>            :                                  real x, real y, const real c[], int n) {
<span class="lineNum">     223 </span>            :     // N.B. n &gt;= 0 and c[] has n+1 elements 0..n, of which c[0] is ignored.
<span class="lineNum">     224 </span>            :     //
<span class="lineNum">     225 </span>            :     // Use Clenshaw summation to evaluate
<span class="lineNum">     226 </span>            :     //   m = (g(x) + g(y)) / 2         -- mean value
<span class="lineNum">     227 </span>            :     //   s = (g(x) - g(y)) / (x - y)   -- average slope
<span class="lineNum">     228 </span>            :     // where
<span class="lineNum">     229 </span>            :     //   g(x) = sum(c[j]*SC(2*j*x), j = 1..n)
<span class="lineNum">     230 </span>            :     //   SC = sinp ? sin : cos
<span class="lineNum">     231 </span>            :     //   CS = sinp ? cos : sin
<span class="lineNum">     232 </span>            :     //
<span class="lineNum">     233 </span>            :     // This function returns only s; m is discarded.
<span class="lineNum">     234 </span>            :     //
<span class="lineNum">     235 </span>            :     // Write
<span class="lineNum">     236 </span>            :     //   t = [m; s]
<span class="lineNum">     237 </span>            :     //   t = sum(c[j] * f[j](x,y), j = 1..n)
<span class="lineNum">     238 </span>            :     // where
<span class="lineNum">     239 </span>            :     //   f[j](x,y) = [ (SC(2*j*x)+SC(2*j*y))/2 ]
<span class="lineNum">     240 </span>            :     //               [ (SC(2*j*x)-SC(2*j*y))/d ]
<span class="lineNum">     241 </span>            :     //
<span class="lineNum">     242 </span>            :     //             = [       cos(j*d)*SC(j*p)    ]
<span class="lineNum">     243 </span>            :     //               [ +/-(2/d)*sin(j*d)*CS(j*p) ]
<span class="lineNum">     244 </span>            :     // (+/- = sinp ? + : -) and
<span class="lineNum">     245 </span>            :     //    p = x+y, d = x-y
<span class="lineNum">     246 </span>            :     //
<span class="lineNum">     247 </span>            :     //   f[j+1](x,y) = A * f[j](x,y) - f[j-1](x,y)
<span class="lineNum">     248 </span>            :     //
<span class="lineNum">     249 </span>            :     //   A = [  2*cos(p)*cos(d)      -sin(p)*sin(d)*d]
<span class="lineNum">     250 </span>            :     //       [ -4*sin(p)*sin(d)/d   2*cos(p)*cos(d)  ]
<span class="lineNum">     251 </span>            :     //
<span class="lineNum">     252 </span>            :     // Let b[n+1] = b[n+2] = [0 0; 0 0]
<span class="lineNum">     253 </span>            :     //     b[j] = A * b[j+1] - b[j+2] + c[j] * I for j = n..1
<span class="lineNum">     254 </span>            :     //    t =  (c[0] * I  - b[2]) * f[0](x,y) + b[1] * f[1](x,y)
<span class="lineNum">     255 </span>            :     // c[0] is not accessed for s = t[2]
<span class="lineNum">     256 </span><span class="lineCov">          9 :     real p = x + y, d = x - y,</span>
<span class="lineNum">     257 </span><span class="lineCov">          9 :       cp = cos(p), cd =          cos(d),</span>
<span class="lineNum">     258 </span><span class="lineCov">          9 :       sp = sin(p), sd = d != 0 ? sin(d)/d : 1,</span>
<span class="lineNum">     259 </span><span class="lineCov">          9 :       m = 2 * cp * cd, s = sp * sd;</span>
<span class="lineNum">     260 </span>            :     // 2x2 matrices stored in row-major order
<span class="lineNum">     261 </span><span class="lineCov">          9 :     const real a[4] = {m, -s * d * d, -4 * s, m};</span>
<span class="lineNum">     262 </span><span class="lineCov">          9 :     real ba[4] = {0, 0, 0, 0};</span>
<span class="lineNum">     263 </span><span class="lineCov">          9 :     real bb[4] = {0, 0, 0, 0};</span>
<span class="lineNum">     264 </span>            :     real* b1 = ba;
<span class="lineNum">     265 </span>            :     real* b2 = bb;
<span class="lineNum">     266 </span><span class="lineCov">          9 :     if (n &gt; 0) b1[0] = b1[3] = c[n];</span>
<span class="lineNum">     267 </span><span class="lineCov">         54 :     for (int j = n - 1; j &gt; 0; --j) { // j = n-1 .. 1</span>
<span class="lineNum">     268 </span>            :       std::swap(b1, b2);
<span class="lineNum">     269 </span>            :       // b1 = A * b2 - b1 + c[j] * I
<span class="lineNum">     270 </span><span class="lineCov">         45 :       b1[0] = a[0] * b2[0] + a[1] * b2[2] - b1[0] + c[j];</span>
<span class="lineNum">     271 </span><span class="lineCov">         45 :       b1[1] = a[0] * b2[1] + a[1] * b2[3] - b1[1];</span>
<span class="lineNum">     272 </span><span class="lineCov">         45 :       b1[2] = a[2] * b2[0] + a[3] * b2[2] - b1[2];</span>
<span class="lineNum">     273 </span><span class="lineCov">         45 :       b1[3] = a[2] * b2[1] + a[3] * b2[3] - b1[3] + c[j];</span>
<span class="lineNum">     274 </span>            :     }
<span class="lineNum">     275 </span>            :     // Here are the full expressions for m and s
<span class="lineNum">     276 </span>            :     // m =   (c[0] - b2[0]) * f01 - b2[1] * f02 + b1[0] * f11 + b1[1] * f12;
<span class="lineNum">     277 </span>            :     // s = - b2[2] * f01 + (c[0] - b2[3]) * f02 + b1[2] * f11 + b1[3] * f12;
<span class="lineNum">     278 </span><span class="lineCov">          9 :     if (sinp) {</span>
<span class="lineNum">     279 </span>            :       // real f01 = 0, f02 = 0;
<span class="lineNum">     280 </span><span class="lineCov">          1 :       real f11 = cd * sp, f12 = 2 * sd * cp;</span>
<span class="lineNum">     281 </span>            :       // m = b1[0] * f11 + b1[1] * f12;
<span class="lineNum">     282 </span><span class="lineCov">          1 :       s = b1[2] * f11 + b1[3] * f12;</span>
<span class="lineNum">     283 </span>            :     } else {
<span class="lineNum">     284 </span>            :       // real f01 = 1, f02 = 0;
<span class="lineNum">     285 </span><span class="lineCov">          8 :       real f11 = cd * cp, f12 = - 2 * sd * sp;</span>
<span class="lineNum">     286 </span>            :       // m = c[0] - b2[0] + b1[0] * f11 + b1[1] * f12;
<span class="lineNum">     287 </span><span class="lineCov">          8 :       s = - b2[2] + b1[2] * f11 + b1[3] * f12;</span>
<span class="lineNum">     288 </span>            :     }
<span class="lineNum">     289 </span><span class="lineCov">          9 :     return s;</span>
<a name="290"><span class="lineNum">     290 </span>            :   }</a>
<span class="lineNum">     291 </span>            : 
<span class="lineNum">     292 </span><span class="lineCov">          1 :   Math::real Rhumb::DConformalToRectifying(real chix, real chiy) const {</span>
<span class="lineNum">     293 </span><span class="lineCov">          1 :     return 1 + SinCosSeries(true, chix, chiy,</span>
<span class="lineNum">     294 </span><span class="lineCov">          1 :                             _ell.ConformalToRectifyingCoeffs(), tm_maxord);</span>
<a name="295"><span class="lineNum">     295 </span>            :   }</a>
<span class="lineNum">     296 </span>            : 
<span class="lineNum">     297 </span><span class="lineNoCov">          0 :   Math::real Rhumb::DRectifyingToConformal(real mux, real muy) const {</span>
<span class="lineNum">     298 </span><span class="lineNoCov">          0 :     return 1 - SinCosSeries(true, mux, muy,</span>
<span class="lineNum">     299 </span><span class="lineNoCov">          0 :                             _ell.RectifyingToConformalCoeffs(), tm_maxord);</span>
<a name="300"><span class="lineNum">     300 </span>            :   }</a>
<span class="lineNum">     301 </span>            : 
<span class="lineNum">     302 </span><span class="lineCov">          8 :   Math::real Rhumb::DIsometricToRectifying(real psix, real psiy) const {</span>
<span class="lineNum">     303 </span><span class="lineCov">          8 :     if (_exact) {</span>
<span class="lineNum">     304 </span>            :       real
<span class="lineNum">     305 </span><span class="lineCov">          7 :         latx = _ell.InverseIsometricLatitude(psix),</span>
<span class="lineNum">     306 </span><span class="lineCov">          7 :         laty = _ell.InverseIsometricLatitude(psiy);</span>
<span class="lineNum">     307 </span><span class="lineCov">          7 :       return DRectifying(latx, laty) / DIsometric(latx, laty);</span>
<span class="lineNum">     308 </span>            :     } else {
<span class="lineNum">     309 </span><span class="lineCov">          1 :       psix *= Math::degree();</span>
<span class="lineNum">     310 </span><span class="lineCov">          1 :       psiy *= Math::degree();</span>
<span class="lineNum">     311 </span><span class="lineCov">          1 :       return DConformalToRectifying(gd(psix), gd(psiy)) * Dgd(psix, psiy);</span>
<span class="lineNum">     312 </span>            :     }
<a name="313"><span class="lineNum">     313 </span>            :   }</a>
<span class="lineNum">     314 </span>            : 
<span class="lineNum">     315 </span><span class="lineNoCov">          0 :   Math::real Rhumb::DRectifyingToIsometric(real mux, real muy) const {</span>
<span class="lineNum">     316 </span>            :     real
<span class="lineNum">     317 </span><span class="lineNoCov">          0 :       latx = _ell.InverseRectifyingLatitude(mux/Math::degree()),</span>
<span class="lineNum">     318 </span><span class="lineNoCov">          0 :       laty = _ell.InverseRectifyingLatitude(muy/Math::degree());</span>
<span class="lineNum">     319 </span><span class="lineNoCov">          0 :     return _exact ?</span>
<span class="lineNum">     320 </span><span class="lineNoCov">          0 :       DIsometric(latx, laty) / DRectifying(latx, laty) :</span>
<span class="lineNum">     321 </span><span class="lineNoCov">          0 :       Dgdinv(Math::taupf(Math::tand(latx), _ell._es),</span>
<span class="lineNum">     322 </span><span class="lineNoCov">          0 :              Math::taupf(Math::tand(laty), _ell._es)) *</span>
<span class="lineNum">     323 </span><span class="lineNoCov">          0 :       DRectifyingToConformal(mux, muy);</span>
<a name="324"><span class="lineNum">     324 </span>            :   }</a>
<span class="lineNum">     325 </span>            : 
<span class="lineNum">     326 </span><span class="lineCov">          8 :   Math::real Rhumb::MeanSinXi(real psix, real psiy) const {</span>
<span class="lineNum">     327 </span><span class="lineCov">         16 :     return Dlog(cosh(psix), cosh(psiy)) * Dcosh(psix, psiy)</span>
<span class="lineNum">     328 </span><span class="lineCov">         16 :       + SinCosSeries(false, gd(psix), gd(psiy), _R, maxpow_) * Dgd(psix, psiy);</span>
<a name="329"><span class="lineNum">     329 </span>            :   }</a>
<span class="lineNum">     330 </span>            : 
<span class="lineNum">     331 </span><span class="lineCov">          2 :   RhumbLine::RhumbLine(const Rhumb&amp; rh, real lat1, real lon1, real azi12,</span>
<span class="lineNum">     332 </span><span class="lineCov">          2 :                        bool exact)</span>
<span class="lineNum">     333 </span>            :     : _rh(rh)
<span class="lineNum">     334 </span>            :     , _exact(exact)
<span class="lineNum">     335 </span>            :     , _lat1(Math::LatFix(lat1))
<span class="lineNum">     336 </span>            :     , _lon1(lon1)
<span class="lineNum">     337 </span><span class="lineCov">          6 :     , _azi12(Math::AngNormalize(azi12))</span>
<span class="lineNum">     338 </span>            :   {
<span class="lineNum">     339 </span><span class="lineCov">          2 :     real alp12 = _azi12 * Math::degree();</span>
<span class="lineNum">     340 </span><span class="lineCov">          2 :     _salp =     _azi12  == -180 ? 0 : sin(alp12);</span>
<span class="lineNum">     341 </span><span class="lineCov">          2 :     _calp = abs(_azi12) ==   90 ? 0 : cos(alp12);</span>
<span class="lineNum">     342 </span><span class="lineCov">          2 :     _mu1 = _rh._ell.RectifyingLatitude(lat1);</span>
<span class="lineNum">     343 </span><span class="lineCov">          2 :     _psi1 = _rh._ell.IsometricLatitude(lat1);</span>
<span class="lineNum">     344 </span><span class="lineCov">          2 :     _r1 = _rh._ell.CircleRadius(lat1);</span>
<a name="345"><span class="lineNum">     345 </span><span class="lineCov">          2 :   }</span></a>
<span class="lineNum">     346 </span>            : 
<span class="lineNum">     347 </span><span class="lineNoCov">          0 :   void RhumbLine::GenPosition(real s12, unsigned outmask,</span>
<span class="lineNum">     348 </span>            :                               real&amp; lat2, real&amp; lon2, real&amp; S12) const {
<span class="lineNum">     349 </span>            :     real
<span class="lineNum">     350 </span><span class="lineNoCov">          0 :       mu12 = s12 * _calp * 90 / _rh._ell.QuarterMeridian(),</span>
<span class="lineNum">     351 </span><span class="lineNoCov">          0 :       mu2 = _mu1 + mu12;</span>
<span class="lineNum">     352 </span>            :     real psi2, lat2x, lon2x;
<span class="lineNum">     353 </span><span class="lineNoCov">          0 :     if (abs(mu2) &lt;= 90) {</span>
<span class="lineNum">     354 </span><span class="lineNoCov">          0 :       if (_calp != 0) {</span>
<span class="lineNum">     355 </span><span class="lineNoCov">          0 :         lat2x = _rh._ell.InverseRectifyingLatitude(mu2);</span>
<span class="lineNum">     356 </span><span class="lineNoCov">          0 :         real psi12 = _rh.DRectifyingToIsometric(  mu2 * Math::degree(),</span>
<span class="lineNum">     357 </span><span class="lineNoCov">          0 :                                                  _mu1 * Math::degree()) * mu12;</span>
<span class="lineNum">     358 </span><span class="lineNoCov">          0 :         lon2x = _salp * psi12 / _calp;</span>
<span class="lineNum">     359 </span><span class="lineNoCov">          0 :         psi2 = _psi1 + psi12;</span>
<span class="lineNum">     360 </span>            :       } else {
<span class="lineNum">     361 </span><span class="lineNoCov">          0 :         lat2x = _lat1;</span>
<span class="lineNum">     362 </span><span class="lineNoCov">          0 :         lon2x = _salp * s12 / (_r1 * Math::degree());</span>
<span class="lineNum">     363 </span><span class="lineNoCov">          0 :         psi2 = _psi1;</span>
<span class="lineNum">     364 </span>            :       }
<span class="lineNum">     365 </span><span class="lineNoCov">          0 :       if (outmask &amp; AREA)</span>
<span class="lineNum">     366 </span><span class="lineNoCov">          0 :         S12 = _rh._c2 * lon2x *</span>
<span class="lineNum">     367 </span><span class="lineNoCov">          0 :           _rh.MeanSinXi(_psi1 * Math::degree(), psi2 * Math::degree());</span>
<span class="lineNum">     368 </span><span class="lineNoCov">          0 :       lon2x = outmask &amp; LONG_UNROLL ? _lon1 + lon2x :</span>
<span class="lineNum">     369 </span><span class="lineNoCov">          0 :         Math::AngNormalize(Math::AngNormalize(_lon1) + lon2x);</span>
<span class="lineNum">     370 </span>            :     } else {
<span class="lineNum">     371 </span>            :       // Reduce to the interval [-180, 180)
<span class="lineNum">     372 </span>            :       mu2 = Math::AngNormalize(mu2);
<span class="lineNum">     373 </span>            :       // Deal with points on the anti-meridian
<span class="lineNum">     374 </span><span class="lineNoCov">          0 :       if (abs(mu2) &gt; 90) mu2 = Math::AngNormalize(180 - mu2);</span>
<span class="lineNum">     375 </span><span class="lineNoCov">          0 :       lat2x = _rh._ell.InverseRectifyingLatitude(mu2);</span>
<span class="lineNum">     376 </span>            :       lon2x = Math::NaN();
<span class="lineNum">     377 </span><span class="lineNoCov">          0 :       if (outmask &amp; AREA)</span>
<span class="lineNum">     378 </span><span class="lineNoCov">          0 :         S12 = Math::NaN();</span>
<span class="lineNum">     379 </span>            :     }
<span class="lineNum">     380 </span><span class="lineNoCov">          0 :     if (outmask &amp; LATITUDE) lat2 = lat2x;</span>
<span class="lineNum">     381 </span><span class="lineNoCov">          0 :     if (outmask &amp; LONGITUDE) lon2 = lon2x;</span>
<span class="lineNum">     382 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     383 </span>            : 
<span class="lineNum">     384 </span>            : } // namespace GeographicLib
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>

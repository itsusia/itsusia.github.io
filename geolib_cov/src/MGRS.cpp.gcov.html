<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - main_coverage.info - src/MGRS.cpp</title>
  <link rel="stylesheet" type="text/css" href="../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../index.html">top level</a> - <a href="index.html">src</a> - MGRS.cpp<span style="font-size: 80%;"> (source / <a href="MGRS.cpp.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">main_coverage.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">117</td>
            <td class="headerCovTableEntry">234</td>
            <td class="headerCovTableEntryLo">50.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2019-11-14 17:15:21</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">5</td>
            <td class="headerCovTableEntry">6</td>
            <td class="headerCovTableEntryMed">83.3 %</td>
          </tr>
          <tr><td><img src="../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /**</a>
<span class="lineNum">       2 </span>            :  * \file MGRS.cpp
<span class="lineNum">       3 </span>            :  * \brief Implementation for GeographicLib::MGRS class
<span class="lineNum">       4 </span>            :  *
<span class="lineNum">       5 </span>            :  * Copyright (c) Charles Karney (2008-2017) &lt;charles@karney.com&gt; and licensed
<span class="lineNum">       6 </span>            :  * under the MIT/X11 License.  For more information, see
<span class="lineNum">       7 </span>            :  * https://geographiclib.sourceforge.io/
<span class="lineNum">       8 </span>            :  **********************************************************************/
<span class="lineNum">       9 </span>            : 
<span class="lineNum">      10 </span>            : #include &lt;GeographicLib/MGRS.hpp&gt;
<span class="lineNum">      11 </span>            : #include &lt;GeographicLib/Utility.hpp&gt;
<span class="lineNum">      12 </span>            : 
<span class="lineNum">      13 </span>            : namespace GeographicLib {
<span class="lineNum">      14 </span>            : 
<span class="lineNum">      15 </span>            :   using namespace std;
<span class="lineNum">      16 </span>            : 
<span class="lineNum">      17 </span>            :   const char* const MGRS::hemispheres_ = &quot;SN&quot;;
<span class="lineNum">      18 </span>            :   const char* const MGRS::utmcols_[] = { &quot;ABCDEFGH&quot;, &quot;JKLMNPQR&quot;, &quot;STUVWXYZ&quot; };
<span class="lineNum">      19 </span>            :   const char* const MGRS::utmrow_ = &quot;ABCDEFGHJKLMNPQRSTUV&quot;;
<span class="lineNum">      20 </span>            :   const char* const MGRS::upscols_[] =
<span class="lineNum">      21 </span>            :     { &quot;JKLPQRSTUXYZ&quot;, &quot;ABCFGHJKLPQR&quot;, &quot;RSTUXYZ&quot;, &quot;ABCFGHJ&quot; };
<span class="lineNum">      22 </span>            :   const char* const MGRS::upsrows_[] =
<span class="lineNum">      23 </span>            :     { &quot;ABCDEFGHJKLMNPQRSTUVWXYZ&quot;, &quot;ABCDEFGHJKLMNP&quot; };
<span class="lineNum">      24 </span>            :   const char* const MGRS::latband_ = &quot;CDEFGHJKLMNPQRSTUVWX&quot;;
<span class="lineNum">      25 </span>            :   const char* const MGRS::upsband_ = &quot;ABYZ&quot;;
<span class="lineNum">      26 </span>            :   const char* const MGRS::digits_ = &quot;0123456789&quot;;
<span class="lineNum">      27 </span>            : 
<span class="lineNum">      28 </span>            :   const int MGRS::mineasting_[] =
<span class="lineNum">      29 </span>            :     { minupsSind_, minupsNind_, minutmcol_, minutmcol_ };
<span class="lineNum">      30 </span>            :   const int MGRS::maxeasting_[] =
<span class="lineNum">      31 </span>            :     { maxupsSind_, maxupsNind_, maxutmcol_, maxutmcol_ };
<span class="lineNum">      32 </span>            :   const int MGRS::minnorthing_[] =
<span class="lineNum">      33 </span>            :     { minupsSind_, minupsNind_,
<span class="lineNum">      34 </span>            :       minutmSrow_, minutmSrow_ - (maxutmSrow_ - minutmNrow_) };
<span class="lineNum">      35 </span>            :   const int MGRS::maxnorthing_[] =
<span class="lineNum">      36 </span>            :     { maxupsSind_, maxupsNind_,
<span class="lineNum">      37 </span>            :       maxutmNrow_ + (maxutmSrow_ - minutmNrow_), maxutmNrow_ };
<span class="lineNum">      38 </span>            : 
<span class="lineNum">      39 </span><span class="lineCov">          4 :   void MGRS::Forward(int zone, bool northp, real x, real y, real lat,</span>
<span class="lineNum">      40 </span>            :                      int prec, std::string&amp; mgrs) {
<span class="lineNum">      41 </span>            :     // The smallest angle s.t., 90 - angeps() &lt; 90 (approx 50e-12 arcsec)
<span class="lineNum">      42 </span>            :     // 7 = ceil(log_2(90))
<span class="lineNum">      43 </span><span class="lineCov">          4 :     static const real angeps = ldexp(real(1), -(Math::digits() - 7));</span>
<span class="lineNum">      44 </span>            :     if (zone == UTMUPS::INVALID ||
<span class="lineNum">      45 </span><span class="lineCov">          8 :         Math::isnan(x) || Math::isnan(y) || Math::isnan(lat)) {</span>
<span class="lineNum">      46 </span>            :       mgrs = &quot;INVALID&quot;;
<span class="lineNum">      47 </span><span class="lineNoCov">          0 :       return;</span>
<span class="lineNum">      48 </span>            :     }
<span class="lineNum">      49 </span><span class="lineCov">          4 :     bool utmp = zone != 0;</span>
<span class="lineNum">      50 </span><span class="lineCov">          4 :     CheckCoords(utmp, northp, x, y);</span>
<span class="lineNum">      51 </span><span class="lineCov">          4 :     if (!(zone &gt;= UTMUPS::MINZONE &amp;&amp; zone &lt;= UTMUPS::MAXZONE))</span>
<span class="lineNum">      52 </span><span class="lineNoCov">          0 :       throw GeographicErr(&quot;Zone &quot; + Utility::str(zone) + &quot; not in [0,60]&quot;);</span>
<span class="lineNum">      53 </span><span class="lineCov">          4 :     if (!(prec &gt;= -1 &amp;&amp; prec &lt;= maxprec_))</span>
<span class="lineNum">      54 </span><span class="lineNoCov">          0 :       throw GeographicErr(&quot;MGRS precision &quot; + Utility::str(prec)</span>
<span class="lineNum">      55 </span><span class="lineNoCov">          0 :                           + &quot; not in [-1, &quot;</span>
<span class="lineNum">      56 </span><span class="lineNoCov">          0 :                           + Utility::str(int(maxprec_)) + &quot;]&quot;);</span>
<span class="lineNum">      57 </span>            :     // Fixed char array for accumulating string.  Allow space for zone, 3 block
<span class="lineNum">      58 </span>            :     // letters, easting + northing.  Don't need to allow for terminating null.
<span class="lineNum">      59 </span>            :     char mgrs1[2 + 3 + 2 * maxprec_];
<span class="lineNum">      60 </span>            :     int
<span class="lineNum">      61 </span><span class="lineCov">          4 :       zone1 = zone - 1,</span>
<span class="lineNum">      62 </span><span class="lineCov">          4 :       z = utmp ? 2 : 0,</span>
<span class="lineNum">      63 </span><span class="lineCov">          4 :       mlen = z + 3 + 2 * prec;</span>
<span class="lineNum">      64 </span><span class="lineCov">          4 :     if (utmp) {</span>
<span class="lineNum">      65 </span><span class="lineCov">          4 :       mgrs1[0] = digits_[ zone / base_ ];</span>
<span class="lineNum">      66 </span><span class="lineCov">          4 :       mgrs1[1] = digits_[ zone % base_ ];</span>
<span class="lineNum">      67 </span>            :       // This isn't necessary...!  Keep y non-neg
<span class="lineNum">      68 </span>            :       // if (!northp) y -= maxutmSrow_ * tile_;
<span class="lineNum">      69 </span>            :     }
<span class="lineNum">      70 </span>            :     // The C++ standard mandates 64 bits for long long.  But
<span class="lineNum">      71 </span>            :     // check, to make sure.
<span class="lineNum">      72 </span>            :     GEOGRAPHICLIB_STATIC_ASSERT(numeric_limits&lt;long long&gt;::digits &gt;= 44,
<span class="lineNum">      73 </span>            :                                 &quot;long long not wide enough to store 10e12&quot;);
<span class="lineNum">      74 </span>            :     long long
<span class="lineNum">      75 </span><span class="lineCov">          4 :       ix = (long long)(floor(x * mult_)),</span>
<span class="lineNum">      76 </span><span class="lineCov">          4 :       iy = (long long)(floor(y * mult_)),</span>
<span class="lineNum">      77 </span>            :       m = (long long)(mult_) * (long long)(tile_);
<span class="lineNum">      78 </span><span class="lineCov">          4 :     int xh = int(ix / m), yh = int(iy / m);</span>
<span class="lineNum">      79 </span><span class="lineCov">          4 :     if (utmp) {</span>
<span class="lineNum">      80 </span>            :       int
<span class="lineNum">      81 </span>            :         // Correct fuzziness in latitude near equator
<span class="lineNum">      82 </span><span class="lineCov">          4 :         iband = abs(lat) &gt; angeps ? LatitudeBand(lat) : (northp ? 0 : -1),</span>
<span class="lineNum">      83 </span><span class="lineCov">          4 :         icol = xh - minutmcol_,</span>
<span class="lineNum">      84 </span><span class="lineCov">          4 :         irow = UTMRow(iband, icol, yh % utmrowperiod_);</span>
<span class="lineNum">      85 </span><span class="lineCov">          4 :       if (irow != yh - (northp ? minutmNrow_ : maxutmSrow_))</span>
<span class="lineNum">      86 </span><span class="lineNoCov">          0 :         throw GeographicErr(&quot;Latitude &quot; + Utility::str(lat)</span>
<span class="lineNum">      87 </span><span class="lineNoCov">          0 :                             + &quot; is inconsistent with UTM coordinates&quot;);</span>
<span class="lineNum">      88 </span><span class="lineCov">          4 :       mgrs1[z++] = latband_[10 + iband];</span>
<span class="lineNum">      89 </span><span class="lineCov">          4 :       mgrs1[z++] = utmcols_[zone1 % 3][icol];</span>
<span class="lineNum">      90 </span><span class="lineCov">          8 :       mgrs1[z++] = utmrow_[(yh + (zone1 &amp; 1 ? utmevenrowshift_ : 0))</span>
<span class="lineNum">      91 </span><span class="lineCov">          4 :                          % utmrowperiod_];</span>
<span class="lineNum">      92 </span>            :     } else {
<span class="lineNum">      93 </span>            :       bool eastp = xh &gt;= upseasting_;
<span class="lineNum">      94 </span><span class="lineNoCov">          0 :       int iband = (northp ? 2 : 0) + (eastp ? 1 : 0);</span>
<span class="lineNum">      95 </span><span class="lineNoCov">          0 :       mgrs1[z++] = upsband_[iband];</span>
<span class="lineNum">      96 </span><span class="lineNoCov">          0 :       mgrs1[z++] = upscols_[iband][xh - (eastp ? upseasting_ :</span>
<span class="lineNum">      97 </span>            :                                          (northp ? minupsNind_ :
<span class="lineNum">      98 </span><span class="lineNoCov">          0 :                                           minupsSind_))];</span>
<span class="lineNum">      99 </span><span class="lineNoCov">          0 :       mgrs1[z++] = upsrows_[northp][yh - (northp ? minupsNind_ : minupsSind_)];</span>
<span class="lineNum">     100 </span>            :     }
<span class="lineNum">     101 </span><span class="lineCov">          4 :     if (prec &gt; 0) {</span>
<span class="lineNum">     102 </span><span class="lineCov">          4 :       ix -= m * xh; iy -= m * yh;</span>
<span class="lineNum">     103 </span><span class="lineCov">          8 :       long long d = (long long)(pow(real(base_), maxprec_ - prec));</span>
<span class="lineNum">     104 </span><span class="lineCov">          4 :       ix /= d; iy /= d;</span>
<span class="lineNum">     105 </span><span class="lineCov">         58 :       for (int c = prec; c--;) {</span>
<span class="lineNum">     106 </span><span class="lineCov">         27 :         mgrs1[z + c       ] = digits_[ix % base_]; ix /= base_;</span>
<span class="lineNum">     107 </span><span class="lineCov">         27 :         mgrs1[z + c + prec] = digits_[iy % base_]; iy /= base_;</span>
<span class="lineNum">     108 </span>            :       }
<span class="lineNum">     109 </span>            :     }
<span class="lineNum">     110 </span><span class="lineCov">          4 :     mgrs.resize(mlen);</span>
<span class="lineNum">     111 </span>            :     copy(mgrs1, mgrs1 + mlen, mgrs.begin());
<a name="112"><span class="lineNum">     112 </span>            :   }</a>
<span class="lineNum">     113 </span>            : 
<span class="lineNum">     114 </span><span class="lineNoCov">          0 :   void MGRS::Forward(int zone, bool northp, real x, real y,</span>
<span class="lineNum">     115 </span>            :                      int prec, std::string&amp; mgrs) {
<span class="lineNum">     116 </span>            :     real lat, lon;
<span class="lineNum">     117 </span><span class="lineNoCov">          0 :     if (zone &gt; 0) {</span>
<span class="lineNum">     118 </span>            :       // Does a rough estimate for latitude determine the latitude band?
<span class="lineNum">     119 </span><span class="lineNoCov">          0 :       real ys = northp ? y : y - utmNshift_;</span>
<span class="lineNum">     120 </span>            :       // A cheap calculation of the latitude which results in an &quot;allowed&quot;
<span class="lineNum">     121 </span>            :       // latitude band would be
<span class="lineNum">     122 </span>            :       //   lat = ApproxLatitudeBand(ys) * 8 + 4;
<span class="lineNum">     123 </span>            :       //
<span class="lineNum">     124 </span>            :       // Here we do a more careful job using the band letter corresponding to
<span class="lineNum">     125 </span>            :       // the actual latitude.
<span class="lineNum">     126 </span><span class="lineNoCov">          0 :       ys /= tile_;</span>
<span class="lineNum">     127 </span><span class="lineNoCov">          0 :       if (abs(ys) &lt; 1)</span>
<span class="lineNum">     128 </span><span class="lineNoCov">          0 :         lat = real(0.9) * ys;         // accurate enough estimate near equator</span>
<span class="lineNum">     129 </span>            :       else {
<span class="lineNum">     130 </span>            :         real
<span class="lineNum">     131 </span>            :           // The poleward bound is a fit from above of lat(x,y)
<span class="lineNum">     132 </span>            :           // for x = 500km and y = [0km, 950km]
<span class="lineNum">     133 </span><span class="lineNoCov">          0 :           latp = real(0.901) * ys + (ys &gt; 0 ? 1 : -1) * real(0.135),</span>
<span class="lineNum">     134 </span>            :           // The equatorward bound is a fit from below of lat(x,y)
<span class="lineNum">     135 </span>            :           // for x = 900km and y = [0km, 950km]
<span class="lineNum">     136 </span><span class="lineNoCov">          0 :           late = real(0.902) * ys * (1 - real(1.85e-6) * ys * ys);</span>
<span class="lineNum">     137 </span><span class="lineNoCov">          0 :         if (LatitudeBand(latp) == LatitudeBand(late))</span>
<span class="lineNum">     138 </span><span class="lineNoCov">          0 :           lat = latp;</span>
<span class="lineNum">     139 </span>            :         else
<span class="lineNum">     140 </span>            :           // bounds straddle a band boundary so need to compute lat accurately
<span class="lineNum">     141 </span><span class="lineNoCov">          0 :           UTMUPS::Reverse(zone, northp, x, y, lat, lon);</span>
<span class="lineNum">     142 </span>            :       }
<span class="lineNum">     143 </span>            :     } else
<span class="lineNum">     144 </span>            :       // Latitude isn't needed for UPS specs or for INVALID
<span class="lineNum">     145 </span><span class="lineNoCov">          0 :       lat = 0;</span>
<span class="lineNum">     146 </span><span class="lineNoCov">          0 :     Forward(zone, northp, x, y, lat, prec, mgrs);</span>
<span class="lineNum">     147 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     148 </span>            : 
<span class="lineNum">     149 </span><span class="lineCov">          2 :   void MGRS::Reverse(const std::string&amp; mgrs,</span>
<span class="lineNum">     150 </span>            :                      int&amp; zone, bool&amp; northp, real&amp; x, real&amp; y,
<span class="lineNum">     151 </span>            :                      int&amp; prec, bool centerp) {
<span class="lineNum">     152 </span>            :     int
<span class="lineNum">     153 </span>            :       p = 0,
<span class="lineNum">     154 </span><span class="lineCov">          2 :       len = int(mgrs.length());</span>
<span class="lineNum">     155 </span><span class="lineCov">          2 :     if (len &gt;= 3 &amp;&amp;</span>
<span class="lineNum">     156 </span><span class="lineCov">          2 :         toupper(mgrs[0]) == 'I' &amp;&amp;</span>
<span class="lineNum">     157 </span><span class="lineCov">          2 :         toupper(mgrs[1]) == 'N' &amp;&amp;</span>
<span class="lineNum">     158 </span><span class="lineNoCov">          0 :         toupper(mgrs[2]) == 'V') {</span>
<span class="lineNum">     159 </span><span class="lineNoCov">          0 :       zone = UTMUPS::INVALID;</span>
<span class="lineNum">     160 </span><span class="lineNoCov">          0 :       northp = false;</span>
<span class="lineNum">     161 </span><span class="lineNoCov">          0 :       x = y = Math::NaN();</span>
<span class="lineNum">     162 </span><span class="lineNoCov">          0 :       prec = -2;</span>
<span class="lineNum">     163 </span><span class="lineNoCov">          0 :       return;</span>
<span class="lineNum">     164 </span>            :     }
<span class="lineNum">     165 </span>            :     int zone1 = 0;
<span class="lineNum">     166 </span><span class="lineCov">          6 :     while (p &lt; len) {</span>
<span class="lineNum">     167 </span><span class="lineCov">          8 :       int i = Utility::lookup(digits_, mgrs[p]);</span>
<span class="lineNum">     168 </span><span class="lineCov">          4 :       if (i &lt; 0)</span>
<span class="lineNum">     169 </span>            :         break;
<span class="lineNum">     170 </span><span class="lineCov">          2 :       zone1 = 10 * zone1 + i;</span>
<span class="lineNum">     171 </span><span class="lineCov">          2 :       ++p;</span>
<span class="lineNum">     172 </span>            :     }
<span class="lineNum">     173 </span><span class="lineCov">          2 :     if (p &gt; 0 &amp;&amp; !(zone1 &gt;= UTMUPS::MINUTMZONE &amp;&amp; zone1 &lt;= UTMUPS::MAXUTMZONE))</span>
<span class="lineNum">     174 </span><span class="lineNoCov">          0 :       throw GeographicErr(&quot;Zone &quot; + Utility::str(zone1) + &quot; not in [1,60]&quot;);</span>
<span class="lineNum">     175 </span><span class="lineCov">          2 :     if (p &gt; 2)</span>
<span class="lineNum">     176 </span>            :       throw GeographicErr(&quot;More than 2 digits at start of MGRS &quot;
<span class="lineNum">     177 </span><span class="lineNoCov">          0 :                           + mgrs.substr(0, p));</span>
<span class="lineNum">     178 </span><span class="lineCov">          2 :     if (len - p &lt; 1)</span>
<span class="lineNum">     179 </span><span class="lineNoCov">          0 :       throw GeographicErr(&quot;MGRS string too short &quot; + mgrs);</span>
<span class="lineNum">     180 </span>            :     bool utmp = zone1 != UTMUPS::UPS;
<span class="lineNum">     181 </span><span class="lineCov">          2 :     int zonem1 = zone1 - 1;</span>
<span class="lineNum">     182 </span><span class="lineCov">          2 :     const char* band = utmp ? latband_ : upsband_;</span>
<span class="lineNum">     183 </span><span class="lineCov">          4 :     int iband = Utility::lookup(band, mgrs[p++]);</span>
<span class="lineNum">     184 </span><span class="lineCov">          2 :     if (iband &lt; 0)</span>
<span class="lineNum">     185 </span><span class="lineCov">          4 :       throw GeographicErr(&quot;Band letter &quot; + Utility::str(mgrs[p-1]) + &quot; not in &quot;</span>
<span class="lineNum">     186 </span><span class="lineCov">          6 :                           + (utmp ? &quot;UTM&quot; : &quot;UPS&quot;) + &quot; set &quot; + band);</span>
<span class="lineNum">     187 </span><span class="lineCov">          1 :     bool northp1 = iband &gt;= (utmp ? 10 : 2);</span>
<span class="lineNum">     188 </span><span class="lineCov">          1 :     if (p == len) {             // Grid zone only (ignore centerp)</span>
<span class="lineNum">     189 </span>            :       // Approx length of a degree of meridian arc in units of tile.
<span class="lineNum">     190 </span>            :       real deg = real(utmNshift_) / (90 * tile_);
<span class="lineNum">     191 </span><span class="lineNoCov">          0 :       zone = zone1;</span>
<span class="lineNum">     192 </span><span class="lineNoCov">          0 :       northp = northp1;</span>
<span class="lineNum">     193 </span><span class="lineNoCov">          0 :       if (utmp) {</span>
<span class="lineNum">     194 </span>            :         // Pick central meridian except for 31V
<span class="lineNum">     195 </span><span class="lineNoCov">          0 :         x = ((zone == 31 &amp;&amp; iband == 17) ? 4 : 5) * tile_;</span>
<span class="lineNum">     196 </span>            :         // Pick center of 8deg latitude bands
<span class="lineNum">     197 </span><span class="lineNoCov">          0 :         y = floor(8 * (iband - real(9.5)) * deg + real(0.5)) * tile_</span>
<span class="lineNum">     198 </span><span class="lineNoCov">          0 :           + (northp ? 0 : utmNshift_);</span>
<span class="lineNum">     199 </span>            :       } else {
<span class="lineNum">     200 </span>            :         // Pick point at lat 86N or 86S
<span class="lineNum">     201 </span><span class="lineNoCov">          0 :         x = ((iband &amp; 1 ? 1 : -1) * floor(4 * deg + real(0.5))</span>
<span class="lineNum">     202 </span><span class="lineNoCov">          0 :              + upseasting_) * tile_;</span>
<span class="lineNum">     203 </span>            :         // Pick point at lon 90E or 90W.
<span class="lineNum">     204 </span><span class="lineNoCov">          0 :         y = upseasting_ * tile_;</span>
<span class="lineNum">     205 </span>            :       }
<span class="lineNum">     206 </span><span class="lineNoCov">          0 :       prec = -1;</span>
<span class="lineNum">     207 </span><span class="lineNoCov">          0 :       return;</span>
<span class="lineNum">     208 </span><span class="lineCov">          1 :     } else if (len - p &lt; 2)</span>
<span class="lineNum">     209 </span><span class="lineNoCov">          0 :       throw GeographicErr(&quot;Missing row letter in &quot; + mgrs);</span>
<span class="lineNum">     210 </span><span class="lineCov">          1 :     const char* col = utmp ? utmcols_[zonem1 % 3] : upscols_[iband];</span>
<span class="lineNum">     211 </span><span class="lineCov">          1 :     const char* row = utmp ? utmrow_ : upsrows_[northp1];</span>
<span class="lineNum">     212 </span><span class="lineCov">          2 :     int icol = Utility::lookup(col, mgrs[p++]);</span>
<span class="lineNum">     213 </span><span class="lineCov">          1 :     if (icol &lt; 0)</span>
<span class="lineNum">     214 </span><span class="lineNoCov">          0 :       throw GeographicErr(&quot;Column letter &quot; + Utility::str(mgrs[p-1])</span>
<span class="lineNum">     215 </span><span class="lineNoCov">          0 :                           + &quot; not in &quot;</span>
<span class="lineNum">     216 </span><span class="lineNoCov">          0 :                           + (utmp ? &quot;zone &quot; + mgrs.substr(0, p-2) :</span>
<span class="lineNum">     217 </span><span class="lineNoCov">          0 :                              &quot;UPS band &quot; + Utility::str(mgrs[p-2]))</span>
<span class="lineNum">     218 </span><span class="lineNoCov">          0 :                           + &quot; set &quot; + col );</span>
<span class="lineNum">     219 </span><span class="lineCov">          2 :     int irow = Utility::lookup(row, mgrs[p++]);</span>
<span class="lineNum">     220 </span><span class="lineCov">          1 :     if (irow &lt; 0)</span>
<span class="lineNum">     221 </span><span class="lineNoCov">          0 :       throw GeographicErr(&quot;Row letter &quot; + Utility::str(mgrs[p-1]) + &quot; not in &quot;</span>
<span class="lineNum">     222 </span><span class="lineNoCov">          0 :                           + (utmp ? &quot;UTM&quot; :</span>
<span class="lineNum">     223 </span><span class="lineNoCov">          0 :                              &quot;UPS &quot; + Utility::str(hemispheres_[northp1]))</span>
<span class="lineNum">     224 </span><span class="lineNoCov">          0 :                           + &quot; set &quot; + row);</span>
<span class="lineNum">     225 </span><span class="lineCov">          1 :     if (utmp) {</span>
<span class="lineNum">     226 </span><span class="lineCov">          1 :       if (zonem1 &amp; 1)</span>
<span class="lineNum">     227 </span><span class="lineCov">          1 :         irow = (irow + utmrowperiod_ - utmevenrowshift_) % utmrowperiod_;</span>
<span class="lineNum">     228 </span><span class="lineCov">          1 :       iband -= 10;</span>
<span class="lineNum">     229 </span><span class="lineCov">          1 :       irow = UTMRow(iband, icol, irow);</span>
<span class="lineNum">     230 </span><span class="lineCov">          1 :       if (irow == maxutmSrow_)</span>
<span class="lineNum">     231 </span><span class="lineNoCov">          0 :         throw GeographicErr(&quot;Block &quot; + mgrs.substr(p-2, 2)</span>
<span class="lineNum">     232 </span><span class="lineNoCov">          0 :                             + &quot; not in zone/band &quot; + mgrs.substr(0, p-2));</span>
<span class="lineNum">     233 </span>            : 
<span class="lineNum">     234 </span><span class="lineCov">          1 :       irow = northp1 ? irow : irow + 100;</span>
<span class="lineNum">     235 </span><span class="lineCov">          1 :       icol = icol + minutmcol_;</span>
<span class="lineNum">     236 </span>            :     } else {
<span class="lineNum">     237 </span><span class="lineNoCov">          0 :       bool eastp = iband &amp; 1;</span>
<span class="lineNum">     238 </span><span class="lineNoCov">          0 :       icol += eastp ? upseasting_ : (northp1 ? minupsNind_ : minupsSind_);</span>
<span class="lineNum">     239 </span><span class="lineNoCov">          0 :       irow += northp1 ? minupsNind_ : minupsSind_;</span>
<span class="lineNum">     240 </span>            :     }
<span class="lineNum">     241 </span><span class="lineCov">          1 :     int prec1 = (len - p)/2;</span>
<span class="lineNum">     242 </span>            :     real
<span class="lineNum">     243 </span>            :       unit = 1,
<span class="lineNum">     244 </span><span class="lineCov">          1 :       x1 = icol,</span>
<span class="lineNum">     245 </span><span class="lineCov">          1 :       y1 = irow;</span>
<span class="lineNum">     246 </span><span class="lineCov">          1 :     for (int i = 0; i &lt; prec1; ++i) {</span>
<span class="lineNum">     247 </span><span class="lineNoCov">          0 :       unit *= base_;</span>
<span class="lineNum">     248 </span>            :       int
<span class="lineNum">     249 </span><span class="lineNoCov">          0 :         ix = Utility::lookup(digits_, mgrs[p + i]),</span>
<span class="lineNum">     250 </span><span class="lineNoCov">          0 :         iy = Utility::lookup(digits_, mgrs[p + i + prec1]);</span>
<span class="lineNum">     251 </span><span class="lineNoCov">          0 :       if (ix &lt; 0 || iy &lt; 0)</span>
<span class="lineNum">     252 </span><span class="lineNoCov">          0 :         throw GeographicErr(&quot;Encountered a non-digit in &quot; + mgrs.substr(p));</span>
<span class="lineNum">     253 </span><span class="lineNoCov">          0 :       x1 = base_ * x1 + ix;</span>
<span class="lineNum">     254 </span><span class="lineNoCov">          0 :       y1 = base_ * y1 + iy;</span>
<span class="lineNum">     255 </span>            :     }
<span class="lineNum">     256 </span><span class="lineCov">          1 :     if ((len - p) % 2) {</span>
<span class="lineNum">     257 </span><span class="lineNoCov">          0 :       if (Utility::lookup(digits_, mgrs[len - 1]) &lt; 0)</span>
<span class="lineNum">     258 </span><span class="lineNoCov">          0 :         throw GeographicErr(&quot;Encountered a non-digit in &quot; + mgrs.substr(p));</span>
<span class="lineNum">     259 </span>            :       else
<span class="lineNum">     260 </span>            :         throw GeographicErr(&quot;Not an even number of digits in &quot;
<span class="lineNum">     261 </span><span class="lineNoCov">          0 :                             + mgrs.substr(p));</span>
<span class="lineNum">     262 </span>            :     }
<span class="lineNum">     263 </span><span class="lineCov">          1 :     if (prec1 &gt; maxprec_)</span>
<span class="lineNum">     264 </span><span class="lineNoCov">          0 :       throw GeographicErr(&quot;More than &quot; + Utility::str(2*maxprec_)</span>
<span class="lineNum">     265 </span><span class="lineNoCov">          0 :                           + &quot; digits in &quot; + mgrs.substr(p));</span>
<span class="lineNum">     266 </span><span class="lineCov">          1 :     if (centerp) {</span>
<span class="lineNum">     267 </span><span class="lineCov">          1 :       unit *= 2; x1 = 2 * x1 + 1; y1 = 2 * y1 + 1;</span>
<span class="lineNum">     268 </span>            :     }
<span class="lineNum">     269 </span><span class="lineCov">          1 :     zone = zone1;</span>
<span class="lineNum">     270 </span><span class="lineCov">          1 :     northp = northp1;</span>
<span class="lineNum">     271 </span><span class="lineCov">          1 :     x = (tile_ * x1) / unit;</span>
<span class="lineNum">     272 </span><span class="lineCov">          1 :     y = (tile_ * y1) / unit;</span>
<span class="lineNum">     273 </span><span class="lineCov">          1 :     prec = prec1;</span>
<span class="lineNum">     274 </span>            :   }
<span class="lineNum">     275 </span>            : 
<span class="lineNum">     276 </span><span class="lineCov">          4 :   void MGRS::CheckCoords(bool utmp, bool&amp; northp, real&amp; x, real&amp; y) {</span>
<span class="lineNum">     277 </span>            :     // Limits are all multiples of 100km and are all closed on the lower end
<span class="lineNum">     278 </span>            :     // and open on the upper end -- and this is reflected in the error
<span class="lineNum">     279 </span>            :     // messages.  However if a coordinate lies on the excluded upper end (e.g.,
<span class="lineNum">     280 </span>            :     // after rounding), it is shifted down by eps.  This also folds UTM
<span class="lineNum">     281 </span>            :     // northings to the correct N/S hemisphere.
<span class="lineNum">     282 </span>            : 
<span class="lineNum">     283 </span>            :     // The smallest length s.t., 1.0e7 - eps() &lt; 1.0e7 (approx 1.9 nm)
<span class="lineNum">     284 </span>            :     // 25 = ceil(log_2(2e7)) -- use half circumference here because
<span class="lineNum">     285 </span>            :     // northing 195e5 is a legal in the &quot;southern&quot; hemisphere.
<span class="lineNum">     286 </span><span class="lineCov">          4 :     static const real eps = ldexp(real(1), -(Math::digits() - 25));</span>
<span class="lineNum">     287 </span>            :     int
<span class="lineNum">     288 </span><span class="lineCov">          4 :       ix = int(floor(x / tile_)),</span>
<span class="lineNum">     289 </span><span class="lineCov">          4 :       iy = int(floor(y / tile_)),</span>
<span class="lineNum">     290 </span><span class="lineCov">          4 :       ind = (utmp ? 2 : 0) + (northp ? 1 : 0);</span>
<span class="lineNum">     291 </span><span class="lineCov">          4 :     if (! (ix &gt;= mineasting_[ind] &amp;&amp; ix &lt; maxeasting_[ind]) ) {</span>
<span class="lineNum">     292 </span><span class="lineNoCov">          0 :       if (ix == maxeasting_[ind] &amp;&amp; x == maxeasting_[ind] * tile_)</span>
<span class="lineNum">     293 </span><span class="lineNoCov">          0 :         x -= eps;</span>
<span class="lineNum">     294 </span>            :       else
<span class="lineNum">     295 </span><span class="lineNoCov">          0 :         throw GeographicErr(&quot;Easting &quot; + Utility::str(int(floor(x/1000)))</span>
<span class="lineNum">     296 </span><span class="lineNoCov">          0 :                             + &quot;km not in MGRS/&quot;</span>
<span class="lineNum">     297 </span><span class="lineNoCov">          0 :                             + (utmp ? &quot;UTM&quot; : &quot;UPS&quot;) + &quot; range for &quot;</span>
<span class="lineNum">     298 </span><span class="lineNoCov">          0 :                             + (northp ? &quot;N&quot; : &quot;S&quot; ) + &quot; hemisphere [&quot;</span>
<span class="lineNum">     299 </span><span class="lineNoCov">          0 :                             + Utility::str(mineasting_[ind]*tile_/1000)</span>
<span class="lineNum">     300 </span><span class="lineNoCov">          0 :                             + &quot;km, &quot;</span>
<span class="lineNum">     301 </span><span class="lineNoCov">          0 :                             + Utility::str(maxeasting_[ind]*tile_/1000)</span>
<span class="lineNum">     302 </span><span class="lineNoCov">          0 :                             + &quot;km)&quot;);</span>
<span class="lineNum">     303 </span>            :     }
<span class="lineNum">     304 </span><span class="lineCov">          4 :     if (! (iy &gt;= minnorthing_[ind] &amp;&amp; iy &lt; maxnorthing_[ind]) ) {</span>
<span class="lineNum">     305 </span><span class="lineNoCov">          0 :       if (iy == maxnorthing_[ind] &amp;&amp; y == maxnorthing_[ind] * tile_)</span>
<span class="lineNum">     306 </span><span class="lineNoCov">          0 :         y -= eps;</span>
<span class="lineNum">     307 </span>            :       else
<span class="lineNum">     308 </span><span class="lineNoCov">          0 :         throw GeographicErr(&quot;Northing &quot; + Utility::str(int(floor(y/1000)))</span>
<span class="lineNum">     309 </span><span class="lineNoCov">          0 :                             + &quot;km not in MGRS/&quot;</span>
<span class="lineNum">     310 </span><span class="lineNoCov">          0 :                             + (utmp ? &quot;UTM&quot; : &quot;UPS&quot;) + &quot; range for &quot;</span>
<span class="lineNum">     311 </span><span class="lineNoCov">          0 :                             + (northp ? &quot;N&quot; : &quot;S&quot; ) + &quot; hemisphere [&quot;</span>
<span class="lineNum">     312 </span><span class="lineNoCov">          0 :                             + Utility::str(minnorthing_[ind]*tile_/1000)</span>
<span class="lineNum">     313 </span><span class="lineNoCov">          0 :                             + &quot;km, &quot;</span>
<span class="lineNum">     314 </span><span class="lineNoCov">          0 :                             + Utility::str(maxnorthing_[ind]*tile_/1000)</span>
<span class="lineNum">     315 </span><span class="lineNoCov">          0 :                             + &quot;km)&quot;);</span>
<span class="lineNum">     316 </span>            :     }
<span class="lineNum">     317 </span>            : 
<span class="lineNum">     318 </span>            :     // Correct the UTM northing and hemisphere if necessary
<span class="lineNum">     319 </span><span class="lineCov">          4 :     if (utmp) {</span>
<span class="lineNum">     320 </span><span class="lineCov">          4 :       if (northp &amp;&amp; iy &lt; minutmNrow_) {</span>
<span class="lineNum">     321 </span><span class="lineNoCov">          0 :         northp = false;</span>
<span class="lineNum">     322 </span><span class="lineNoCov">          0 :         y += utmNshift_;</span>
<span class="lineNum">     323 </span><span class="lineCov">          4 :       } else if (!northp &amp;&amp; iy &gt;= maxutmSrow_) {</span>
<span class="lineNum">     324 </span><span class="lineNoCov">          0 :         if (y == maxutmSrow_ * tile_)</span>
<span class="lineNum">     325 </span>            :           // If on equator retain S hemisphere
<span class="lineNum">     326 </span><span class="lineNoCov">          0 :           y -= eps;</span>
<span class="lineNum">     327 </span>            :         else {
<span class="lineNum">     328 </span><span class="lineNoCov">          0 :           northp = true;</span>
<span class="lineNum">     329 </span><span class="lineNoCov">          0 :           y -= utmNshift_;</span>
<span class="lineNum">     330 </span>            :         }
<span class="lineNum">     331 </span>            :       }
<span class="lineNum">     332 </span>            :     }
<a name="333"><span class="lineNum">     333 </span><span class="lineCov">          4 :   }</span></a>
<span class="lineNum">     334 </span>            : 
<span class="lineNum">     335 </span><span class="lineCov">          5 :   int MGRS::UTMRow(int iband, int icol, int irow) {</span>
<span class="lineNum">     336 </span>            :     // Input is iband = band index in [-10, 10) (as returned by LatitudeBand),
<span class="lineNum">     337 </span>            :     // icol = column index in [0,8) with origin of easting = 100km, and irow =
<span class="lineNum">     338 </span>            :     // periodic row index in [0,20) with origin = equator.  Output is true row
<span class="lineNum">     339 </span>            :     // index in [-90, 95).  Returns maxutmSrow_ = 100, if irow and iband are
<span class="lineNum">     340 </span>            :     // incompatible.
<span class="lineNum">     341 </span>            : 
<span class="lineNum">     342 </span>            :     // Estimate center row number for latitude band
<span class="lineNum">     343 </span>            :     // 90 deg = 100 tiles; 1 band = 8 deg = 100*8/90 tiles
<span class="lineNum">     344 </span><span class="lineCov">          5 :     real c = 100 * (8 * iband + 4)/real(90);</span>
<span class="lineNum">     345 </span><span class="lineCov">          5 :     bool northp = iband &gt;= 0;</span>
<span class="lineNum">     346 </span>            :     // These are safe bounds on the rows
<span class="lineNum">     347 </span>            :     //  iband minrow maxrow
<span class="lineNum">     348 </span>            :     //   -10    -90    -81
<span class="lineNum">     349 </span>            :     //    -9    -80    -72
<span class="lineNum">     350 </span>            :     //    -8    -71    -63
<span class="lineNum">     351 </span>            :     //    -7    -63    -54
<span class="lineNum">     352 </span>            :     //    -6    -54    -45
<span class="lineNum">     353 </span>            :     //    -5    -45    -36
<span class="lineNum">     354 </span>            :     //    -4    -36    -27
<span class="lineNum">     355 </span>            :     //    -3    -27    -18
<span class="lineNum">     356 </span>            :     //    -2    -18     -9
<span class="lineNum">     357 </span>            :     //    -1     -9     -1
<span class="lineNum">     358 </span>            :     //     0      0      8
<span class="lineNum">     359 </span>            :     //     1      8     17
<span class="lineNum">     360 </span>            :     //     2     17     26
<span class="lineNum">     361 </span>            :     //     3     26     35
<span class="lineNum">     362 </span>            :     //     4     35     44
<span class="lineNum">     363 </span>            :     //     5     44     53
<span class="lineNum">     364 </span>            :     //     6     53     62
<span class="lineNum">     365 </span>            :     //     7     62     70
<span class="lineNum">     366 </span>            :     //     8     71     79
<span class="lineNum">     367 </span>            :     //     9     80     94
<span class="lineNum">     368 </span>            :     int
<span class="lineNum">     369 </span><span class="lineCov">         10 :       minrow = iband &gt; -10 ?</span>
<span class="lineNum">     370 </span><span class="lineCov">          5 :       int(floor(c - real(4.3) - real(0.1) * northp)) : -90,</span>
<span class="lineNum">     371 </span><span class="lineCov">         10 :       maxrow = iband &lt;   9 ?</span>
<span class="lineNum">     372 </span><span class="lineCov">          5 :       int(floor(c + real(4.4) - real(0.1) * northp)) :  94,</span>
<span class="lineNum">     373 </span><span class="lineCov">          5 :       baserow = (minrow + maxrow) / 2 - utmrowperiod_ / 2;</span>
<span class="lineNum">     374 </span>            :     // Offset irow by the multiple of utmrowperiod_ which brings it as close as
<span class="lineNum">     375 </span>            :     // possible to the center of the latitude band, (minrow + maxrow) / 2.
<span class="lineNum">     376 </span>            :     // (Add maxutmSrow_ = 5 * utmrowperiod_ to ensure operand is positive.)
<span class="lineNum">     377 </span><span class="lineCov">          5 :     irow = (irow - baserow + maxutmSrow_) % utmrowperiod_ + baserow;</span>
<span class="lineNum">     378 </span><span class="lineCov">          5 :     if (!( irow &gt;= minrow &amp;&amp; irow &lt;= maxrow )) {</span>
<span class="lineNum">     379 </span>            :       // Outside the safe bounds, so need to check...
<span class="lineNum">     380 </span>            :       // Northing = 71e5 and 80e5 intersect band boundaries
<span class="lineNum">     381 </span>            :       //   y = 71e5 in scol = 2 (x = [3e5,4e5] and x = [6e5,7e5])
<span class="lineNum">     382 </span>            :       //   y = 80e5 in scol = 1 (x = [2e5,3e5] and x = [7e5,8e5])
<span class="lineNum">     383 </span>            :       // This holds for all the ellipsoids given in NGA.SIG.0012_2.0.0_UTMUPS.
<span class="lineNum">     384 </span>            :       // The following deals with these special cases.
<span class="lineNum">     385 </span>            :       int
<span class="lineNum">     386 </span>            :         // Fold [-10,-1] -&gt; [9,0]
<span class="lineNum">     387 </span><span class="lineNoCov">          0 :         sband = iband &gt;= 0 ? iband : -iband - 1,</span>
<span class="lineNum">     388 </span>            :         // Fold [-90,-1] -&gt; [89,0]
<span class="lineNum">     389 </span><span class="lineNoCov">          0 :         srow = irow &gt;= 0 ? irow : -irow - 1,</span>
<span class="lineNum">     390 </span>            :         // Fold [4,7] -&gt; [3,0]
<span class="lineNum">     391 </span><span class="lineNoCov">          0 :         scol = icol &lt; 4 ? icol : -icol + 7;</span>
<span class="lineNum">     392 </span>            :       // For example, the safe rows for band 8 are 71 - 79.  However row 70 is
<span class="lineNum">     393 </span>            :       // allowed if scol = [2,3] and row 80 is allowed if scol = [0,1].
<span class="lineNum">     394 </span><span class="lineNoCov">          0 :       if ( ! ( (srow == 70 &amp;&amp; sband == 8 &amp;&amp; scol &gt;= 2) ||</span>
<span class="lineNum">     395 </span><span class="lineNoCov">          0 :                (srow == 71 &amp;&amp; sband == 7 &amp;&amp; scol &lt;= 2) ||</span>
<span class="lineNum">     396 </span><span class="lineNoCov">          0 :                (srow == 79 &amp;&amp; sband == 9 &amp;&amp; scol &gt;= 1) ||</span>
<span class="lineNum">     397 </span><span class="lineNoCov">          0 :                (srow == 80 &amp;&amp; sband == 8 &amp;&amp; scol &lt;= 1) ) )</span>
<span class="lineNum">     398 </span>            :         irow = maxutmSrow_;
<span class="lineNum">     399 </span>            :     }
<span class="lineNum">     400 </span><span class="lineCov">          5 :     return irow;</span>
<span class="lineNum">     401 </span>            :   }
<span class="lineNum">     402 </span>            : 
<span class="lineNum">     403 </span><span class="lineCov">          1 :   void MGRS::Check() {</span>
<span class="lineNum">     404 </span>            :     real lat, lon, x, y, t = tile_; int zone; bool northp;
<span class="lineNum">     405 </span>            :     UTMUPS::Reverse(31, true , 1*t,  0*t, lat, lon);
<span class="lineNum">     406 </span><span class="lineCov">          1 :     if (!( lon &lt;   0 ))</span>
<span class="lineNum">     407 </span><span class="lineNoCov">          0 :       throw GeographicErr(&quot;MGRS::Check: equator coverage failure&quot;);</span>
<span class="lineNum">     408 </span>            :     UTMUPS::Reverse(31, true , 1*t, 95*t, lat, lon);
<span class="lineNum">     409 </span><span class="lineCov">          1 :     if (!( lat &gt;  84 ))</span>
<span class="lineNum">     410 </span><span class="lineNoCov">          0 :       throw GeographicErr(&quot;MGRS::Check: UTM doesn't reach latitude = 84&quot;);</span>
<span class="lineNum">     411 </span>            :     UTMUPS::Reverse(31, false, 1*t, 10*t, lat, lon);
<span class="lineNum">     412 </span><span class="lineCov">          1 :     if (!( lat &lt; -80 ))</span>
<span class="lineNum">     413 </span><span class="lineNoCov">          0 :       throw GeographicErr(&quot;MGRS::Check: UTM doesn't reach latitude = -80&quot;);</span>
<span class="lineNum">     414 </span>            :     UTMUPS::Forward(56,  3, zone, northp, x, y, 32);
<span class="lineNum">     415 </span><span class="lineCov">          1 :     if (!( x &gt; 1*t ))</span>
<span class="lineNum">     416 </span><span class="lineNoCov">          0 :       throw GeographicErr(&quot;MGRS::Check: Norway exception creates a gap&quot;);</span>
<span class="lineNum">     417 </span>            :     UTMUPS::Forward(72, 21, zone, northp, x, y, 35);
<span class="lineNum">     418 </span><span class="lineCov">          1 :     if (!( x &gt; 1*t ))</span>
<span class="lineNum">     419 </span><span class="lineNoCov">          0 :       throw GeographicErr(&quot;MGRS::Check: Svalbard exception creates a gap&quot;);</span>
<span class="lineNum">     420 </span>            :     UTMUPS::Reverse(0, true , 20*t, 13*t, lat, lon);
<span class="lineNum">     421 </span><span class="lineCov">          1 :     if (!( lat &lt;  84 ))</span>
<span class="lineNum">     422 </span>            :       throw
<span class="lineNum">     423 </span><span class="lineNoCov">          0 :         GeographicErr(&quot;MGRS::Check: North UPS doesn't reach latitude = 84&quot;);</span>
<span class="lineNum">     424 </span>            :     UTMUPS::Reverse(0, false, 20*t,  8*t, lat, lon);
<span class="lineNum">     425 </span><span class="lineCov">          1 :     if (!( lat &gt; -80 ))</span>
<span class="lineNum">     426 </span>            :       throw
<span class="lineNum">     427 </span><span class="lineNoCov">          0 :         GeographicErr(&quot;MGRS::Check: South UPS doesn't reach latitude = -80&quot;);</span>
<span class="lineNum">     428 </span>            :     // Entries are [band, x, y] either side of the band boundaries.  Units for
<span class="lineNum">     429 </span>            :     // x, y are t = 100km.
<span class="lineNum">     430 </span><span class="lineCov">          1 :     const short tab[] = {</span>
<span class="lineNum">     431 </span>            :       0, 5,  0,   0, 9,  0,     // south edge of band 0
<span class="lineNum">     432 </span>            :       0, 5,  8,   0, 9,  8,     // north edge of band 0
<span class="lineNum">     433 </span>            :       1, 5,  9,   1, 9,  9,     // south edge of band 1
<span class="lineNum">     434 </span>            :       1, 5, 17,   1, 9, 17,     // north edge of band 1
<span class="lineNum">     435 </span>            :       2, 5, 18,   2, 9, 18,     // etc.
<span class="lineNum">     436 </span>            :       2, 5, 26,   2, 9, 26,
<span class="lineNum">     437 </span>            :       3, 5, 27,   3, 9, 27,
<span class="lineNum">     438 </span>            :       3, 5, 35,   3, 9, 35,
<span class="lineNum">     439 </span>            :       4, 5, 36,   4, 9, 36,
<span class="lineNum">     440 </span>            :       4, 5, 44,   4, 9, 44,
<span class="lineNum">     441 </span>            :       5, 5, 45,   5, 9, 45,
<span class="lineNum">     442 </span>            :       5, 5, 53,   5, 9, 53,
<span class="lineNum">     443 </span>            :       6, 5, 54,   6, 9, 54,
<span class="lineNum">     444 </span>            :       6, 5, 62,   6, 9, 62,
<span class="lineNum">     445 </span>            :       7, 5, 63,   7, 9, 63,
<span class="lineNum">     446 </span>            :       7, 5, 70,   7, 7, 70,   7, 7, 71,   7, 9, 71, // y = 71t crosses boundary
<span class="lineNum">     447 </span>            :       8, 5, 71,   8, 6, 71,   8, 6, 72,   8, 9, 72, // between bands 7 and 8.
<span class="lineNum">     448 </span>            :       8, 5, 79,   8, 8, 79,   8, 8, 80,   8, 9, 80, // y = 80t crosses boundary
<span class="lineNum">     449 </span>            :       9, 5, 80,   9, 7, 80,   9, 7, 81,   9, 9, 81, // between bands 8 and 9.
<span class="lineNum">     450 </span>            :       9, 5, 95,   9, 9, 95,     // north edge of band 9
<span class="lineNum">     451 </span>            :     };
<span class="lineNum">     452 </span>            :     const int bandchecks = sizeof(tab) / (3 * sizeof(short));
<span class="lineNum">     453 </span><span class="lineCov">         97 :     for (int i = 0; i &lt; bandchecks; ++i) {</span>
<span class="lineNum">     454 </span><span class="lineCov">         48 :       UTMUPS::Reverse(38, true, tab[3*i+1]*t, tab[3*i+2]*t, lat, lon);</span>
<span class="lineNum">     455 </span><span class="lineCov">         48 :       if (!( LatitudeBand(lat) == tab[3*i+0] ))</span>
<span class="lineNum">     456 </span><span class="lineNoCov">          0 :         throw GeographicErr(&quot;MGRS::Check: Band error, b = &quot; +</span>
<span class="lineNum">     457 </span><span class="lineNoCov">          0 :                             Utility::str(tab[3*i+0]) + &quot;, x = &quot; +</span>
<span class="lineNum">     458 </span><span class="lineNoCov">          0 :                             Utility::str(tab[3*i+1]) + &quot;00km, y = &quot; +</span>
<span class="lineNum">     459 </span><span class="lineNoCov">          0 :                             Utility::str(tab[3*i+2]) + &quot;00km&quot;);</span>
<span class="lineNum">     460 </span>            :     }
<span class="lineNum">     461 </span><span class="lineCov">          1 :   }</span>
<span class="lineNum">     462 </span>            : 
<span class="lineNum">     463 </span>            : } // namespace GeographicLib
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>

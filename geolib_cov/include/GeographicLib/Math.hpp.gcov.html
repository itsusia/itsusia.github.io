<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - main_coverage.info - include/GeographicLib/Math.hpp</title>
  <link rel="stylesheet" type="text/css" href="../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">include/GeographicLib</a> - Math.hpp<span style="font-size: 80%;"> (source / <a href="Math.hpp.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">main_coverage.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">59</td>
            <td class="headerCovTableEntry">74</td>
            <td class="headerCovTableEntryMed">79.7 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2019-11-14 17:15:21</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">6</td>
            <td class="headerCovTableEntry">7</td>
            <td class="headerCovTableEntryMed">85.7 %</td>
          </tr>
          <tr><td><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /**</a>
<span class="lineNum">       2 </span>            :  * \file Math.hpp
<span class="lineNum">       3 </span>            :  * \brief Header for GeographicLib::Math class
<span class="lineNum">       4 </span>            :  *
<span class="lineNum">       5 </span>            :  * Copyright (c) Charles Karney (2008-2017) &lt;charles@karney.com&gt; and licensed
<span class="lineNum">       6 </span>            :  * under the MIT/X11 License.  For more information, see
<span class="lineNum">       7 </span>            :  * https://geographiclib.sourceforge.io/
<span class="lineNum">       8 </span>            :  **********************************************************************/
<span class="lineNum">       9 </span>            : 
<span class="lineNum">      10 </span>            : // Constants.hpp includes Math.hpp.  Place this include outside Math.hpp's
<span class="lineNum">      11 </span>            : // include guard to enforce this ordering.
<span class="lineNum">      12 </span>            : #include &lt;GeographicLib/Constants.hpp&gt;
<span class="lineNum">      13 </span>            : 
<span class="lineNum">      14 </span>            : #if !defined(GEOGRAPHICLIB_MATH_HPP)
<span class="lineNum">      15 </span>            : #define GEOGRAPHICLIB_MATH_HPP 1
<span class="lineNum">      16 </span>            : 
<span class="lineNum">      17 </span>            : /**
<span class="lineNum">      18 </span>            :  * Are C++11 math functions available?
<span class="lineNum">      19 </span>            :  **********************************************************************/
<span class="lineNum">      20 </span>            : #if !defined(GEOGRAPHICLIB_CXX11_MATH)
<span class="lineNum">      21 </span>            : // Recent versions of g++ -std=c++11 (4.7 and later?) set __cplusplus to 201103
<span class="lineNum">      22 </span>            : // and support the new C++11 mathematical functions, std::atanh, etc.  However
<span class="lineNum">      23 </span>            : // the Android toolchain, which uses g++ -std=c++11 (4.8 as of 2014-03-11,
<span class="lineNum">      24 </span>            : // according to Pullan Lu), does not support std::atanh.  Android toolchains
<span class="lineNum">      25 </span>            : // might define __ANDROID__ or ANDROID; so need to check both.  With OSX the
<span class="lineNum">      26 </span>            : // version is GNUC version 4.2 and __cplusplus is set to 201103, so remove the
<span class="lineNum">      27 </span>            : // version check on GNUC.
<span class="lineNum">      28 </span>            : #  if defined(__GNUC__) &amp;&amp; __cplusplus &gt;= 201103 &amp;&amp; \
<span class="lineNum">      29 </span>            :   !(defined(__ANDROID__) || defined(ANDROID) || defined(__CYGWIN__))
<span class="lineNum">      30 </span>            : #    define GEOGRAPHICLIB_CXX11_MATH 1
<span class="lineNum">      31 </span>            : // Visual C++ 12 supports these functions
<span class="lineNum">      32 </span>            : #  elif defined(_MSC_VER) &amp;&amp; _MSC_VER &gt;= 1800
<span class="lineNum">      33 </span>            : #    define GEOGRAPHICLIB_CXX11_MATH 1
<span class="lineNum">      34 </span>            : #  else
<span class="lineNum">      35 </span>            : #    define GEOGRAPHICLIB_CXX11_MATH 0
<span class="lineNum">      36 </span>            : #  endif
<span class="lineNum">      37 </span>            : #endif
<span class="lineNum">      38 </span>            : 
<span class="lineNum">      39 </span>            : #if !defined(GEOGRAPHICLIB_WORDS_BIGENDIAN)
<span class="lineNum">      40 </span>            : #  define GEOGRAPHICLIB_WORDS_BIGENDIAN 0
<span class="lineNum">      41 </span>            : #endif
<span class="lineNum">      42 </span>            : 
<span class="lineNum">      43 </span>            : #if !defined(GEOGRAPHICLIB_HAVE_LONG_DOUBLE)
<span class="lineNum">      44 </span>            : #  define GEOGRAPHICLIB_HAVE_LONG_DOUBLE 0
<span class="lineNum">      45 </span>            : #endif
<span class="lineNum">      46 </span>            : 
<span class="lineNum">      47 </span>            : #if !defined(GEOGRAPHICLIB_PRECISION)
<span class="lineNum">      48 </span>            : /**
<span class="lineNum">      49 </span>            :  * The precision of floating point numbers used in %GeographicLib.  1 means
<span class="lineNum">      50 </span>            :  * float (single precision); 2 (the default) means double; 3 means long double;
<span class="lineNum">      51 </span>            :  * 4 is reserved for quadruple precision.  Nearly all the testing has been
<span class="lineNum">      52 </span>            :  * carried out with doubles and that's the recommended configuration.  In order
<span class="lineNum">      53 </span>            :  * for long double to be used, GEOGRAPHICLIB_HAVE_LONG_DOUBLE needs to be
<span class="lineNum">      54 </span>            :  * defined.  Note that with Microsoft Visual Studio, long double is the same as
<span class="lineNum">      55 </span>            :  * double.
<span class="lineNum">      56 </span>            :  **********************************************************************/
<span class="lineNum">      57 </span>            : #  define GEOGRAPHICLIB_PRECISION 2
<span class="lineNum">      58 </span>            : #endif
<span class="lineNum">      59 </span>            : 
<span class="lineNum">      60 </span>            : #include &lt;cmath&gt;
<span class="lineNum">      61 </span>            : #include &lt;algorithm&gt;
<span class="lineNum">      62 </span>            : #include &lt;limits&gt;
<span class="lineNum">      63 </span>            : 
<span class="lineNum">      64 </span>            : #if GEOGRAPHICLIB_PRECISION == 4
<span class="lineNum">      65 </span>            : #include &lt;boost/version.hpp&gt;
<span class="lineNum">      66 </span>            : #if BOOST_VERSION &gt;= 105600
<span class="lineNum">      67 </span>            : #include &lt;boost/cstdfloat.hpp&gt;
<span class="lineNum">      68 </span>            : #endif
<span class="lineNum">      69 </span>            : #include &lt;boost/multiprecision/float128.hpp&gt;
<span class="lineNum">      70 </span>            : #include &lt;boost/math/special_functions.hpp&gt;
<span class="lineNum">      71 </span>            : __float128 fmaq(__float128, __float128, __float128);
<span class="lineNum">      72 </span>            : #elif GEOGRAPHICLIB_PRECISION == 5
<span class="lineNum">      73 </span>            : #include &lt;mpreal.h&gt;
<span class="lineNum">      74 </span>            : #endif
<span class="lineNum">      75 </span>            : 
<span class="lineNum">      76 </span>            : #if GEOGRAPHICLIB_PRECISION &gt; 3
<span class="lineNum">      77 </span>            : // volatile keyword makes no sense for multiprec types
<span class="lineNum">      78 </span>            : #define GEOGRAPHICLIB_VOLATILE
<span class="lineNum">      79 </span>            : // Signal a convergence failure with multiprec types by throwing an exception
<span class="lineNum">      80 </span>            : // at loop exit.
<span class="lineNum">      81 </span>            : #define GEOGRAPHICLIB_PANIC \
<span class="lineNum">      82 </span>            :   (throw GeographicLib::GeographicErr(&quot;Convergence failure&quot;), false)
<span class="lineNum">      83 </span>            : #else
<span class="lineNum">      84 </span>            : #define GEOGRAPHICLIB_VOLATILE volatile
<span class="lineNum">      85 </span>            : // Ignore convergence failures with standard floating points types by allowing
<span class="lineNum">      86 </span>            : // loop to exit cleanly.
<span class="lineNum">      87 </span>            : #define GEOGRAPHICLIB_PANIC false
<span class="lineNum">      88 </span>            : #endif
<span class="lineNum">      89 </span>            : 
<span class="lineNum">      90 </span>            : namespace GeographicLib {
<span class="lineNum">      91 </span>            : 
<span class="lineNum">      92 </span>            :   /**
<span class="lineNum">      93 </span>            :    * \brief Mathematical functions needed by %GeographicLib
<span class="lineNum">      94 </span>            :    *
<span class="lineNum">      95 </span>            :    * Define mathematical functions in order to localize system dependencies and
<span class="lineNum">      96 </span>            :    * to provide generic versions of the functions.  In addition define a real
<span class="lineNum">      97 </span>            :    * type to be used by %GeographicLib.
<span class="lineNum">      98 </span>            :    *
<span class="lineNum">      99 </span>            :    * Example of use:
<span class="lineNum">     100 </span>            :    * \include example-Math.cpp
<span class="lineNum">     101 </span>            :    **********************************************************************/
<span class="lineNum">     102 </span>            :   class GEOGRAPHICLIB_EXPORT Math {
<span class="lineNum">     103 </span>            :   private:
<span class="lineNum">     104 </span>            :     void dummy() {
<span class="lineNum">     105 </span>            :       GEOGRAPHICLIB_STATIC_ASSERT(GEOGRAPHICLIB_PRECISION &gt;= 1 &amp;&amp;
<span class="lineNum">     106 </span>            :                                   GEOGRAPHICLIB_PRECISION &lt;= 5,
<span class="lineNum">     107 </span>            :                                   &quot;Bad value of precision&quot;);
<span class="lineNum">     108 </span>            :     }
<span class="lineNum">     109 </span>            :     Math();                     // Disable constructor
<span class="lineNum">     110 </span>            :   public:
<span class="lineNum">     111 </span>            : 
<span class="lineNum">     112 </span>            : #if GEOGRAPHICLIB_HAVE_LONG_DOUBLE
<span class="lineNum">     113 </span>            :     /**
<span class="lineNum">     114 </span>            :      * The extended precision type for real numbers, used for some testing.
<span class="lineNum">     115 </span>            :      * This is long double on computers with this type; otherwise it is double.
<span class="lineNum">     116 </span>            :      **********************************************************************/
<span class="lineNum">     117 </span>            :     typedef long double extended;
<span class="lineNum">     118 </span>            : #else
<span class="lineNum">     119 </span>            :     typedef double extended;
<span class="lineNum">     120 </span>            : #endif
<span class="lineNum">     121 </span>            : 
<span class="lineNum">     122 </span>            : #if GEOGRAPHICLIB_PRECISION == 2
<span class="lineNum">     123 </span>            :     /**
<span class="lineNum">     124 </span>            :      * The real type for %GeographicLib. Nearly all the testing has been done
<span class="lineNum">     125 </span>            :      * with \e real = double.  However, the algorithms should also work with
<span class="lineNum">     126 </span>            :      * float and long double (where available).  (&lt;b&gt;CAUTION&lt;/b&gt;: reasonable
<span class="lineNum">     127 </span>            :      * accuracy typically cannot be obtained using floats.)
<span class="lineNum">     128 </span>            :      **********************************************************************/
<span class="lineNum">     129 </span>            :     typedef double real;
<span class="lineNum">     130 </span>            : #elif GEOGRAPHICLIB_PRECISION == 1
<span class="lineNum">     131 </span>            :     typedef float real;
<span class="lineNum">     132 </span>            : #elif GEOGRAPHICLIB_PRECISION == 3
<span class="lineNum">     133 </span>            :     typedef extended real;
<span class="lineNum">     134 </span>            : #elif GEOGRAPHICLIB_PRECISION == 4
<span class="lineNum">     135 </span>            :     typedef boost::multiprecision::float128 real;
<span class="lineNum">     136 </span>            : #elif GEOGRAPHICLIB_PRECISION == 5
<span class="lineNum">     137 </span>            :     typedef mpfr::mpreal real;
<span class="lineNum">     138 </span>            : #else
<span class="lineNum">     139 </span>            :     typedef double real;
<span class="lineNum">     140 </span>            : #endif
<span class="lineNum">     141 </span>            : 
<span class="lineNum">     142 </span>            :     /**
<span class="lineNum">     143 </span>            :      * @return the number of bits of precision in a real number.
<span class="lineNum">     144 </span>            :      **********************************************************************/
<span class="lineNum">     145 </span>            :     static int digits() {
<span class="lineNum">     146 </span>            : #if GEOGRAPHICLIB_PRECISION != 5
<span class="lineNum">     147 </span>            :       return std::numeric_limits&lt;real&gt;::digits;
<span class="lineNum">     148 </span>            : #else
<span class="lineNum">     149 </span>            :       return std::numeric_limits&lt;real&gt;::digits();
<span class="lineNum">     150 </span>            : #endif
<span class="lineNum">     151 </span>            :     }
<span class="lineNum">     152 </span>            : 
<span class="lineNum">     153 </span>            :     /**
<span class="lineNum">     154 </span>            :      * Set the binary precision of a real number.
<span class="lineNum">     155 </span>            :      *
<span class="lineNum">     156 </span>            :      * @param[in] ndigits the number of bits of precision.
<span class="lineNum">     157 </span>            :      * @return the resulting number of bits of precision.
<span class="lineNum">     158 </span>            :      *
<span class="lineNum">     159 </span>            :      * This only has an effect when GEOGRAPHICLIB_PRECISION = 5.  See also
<span class="lineNum">     160 </span>            :      * Utility::set_digits for caveats about when this routine should be
<span class="lineNum">     161 </span>            :      * called.
<span class="lineNum">     162 </span>            :      **********************************************************************/
<span class="lineNum">     163 </span>            :     static int set_digits(int ndigits) {
<span class="lineNum">     164 </span>            : #if GEOGRAPHICLIB_PRECISION != 5
<span class="lineNum">     165 </span>            :       (void)ndigits;
<span class="lineNum">     166 </span>            : #else
<span class="lineNum">     167 </span>            :       mpfr::mpreal::set_default_prec(ndigits &gt;= 2 ? ndigits : 2);
<span class="lineNum">     168 </span>            : #endif
<span class="lineNum">     169 </span>            :       return digits();
<span class="lineNum">     170 </span>            :     }
<span class="lineNum">     171 </span>            : 
<span class="lineNum">     172 </span>            :     /**
<span class="lineNum">     173 </span>            :      * @return the number of decimal digits of precision in a real number.
<span class="lineNum">     174 </span>            :      **********************************************************************/
<span class="lineNum">     175 </span>            :     static int digits10() {
<span class="lineNum">     176 </span>            : #if GEOGRAPHICLIB_PRECISION != 5
<span class="lineNum">     177 </span>            :       return std::numeric_limits&lt;real&gt;::digits10;
<span class="lineNum">     178 </span>            : #else
<span class="lineNum">     179 </span>            :       return std::numeric_limits&lt;real&gt;::digits10();
<span class="lineNum">     180 </span>            : #endif
<span class="lineNum">     181 </span>            :     }
<span class="lineNum">     182 </span>            : 
<span class="lineNum">     183 </span>            :     /**
<span class="lineNum">     184 </span>            :      * Number of additional decimal digits of precision for real relative to
<span class="lineNum">     185 </span>            :      * double (0 for float).
<span class="lineNum">     186 </span>            :      **********************************************************************/
<span class="lineNum">     187 </span>            :     static int extra_digits() {
<span class="lineNum">     188 </span>            :       return
<span class="lineNum">     189 </span>            :         digits10() &gt; std::numeric_limits&lt;double&gt;::digits10 ?
<span class="lineNum">     190 </span>            :         digits10() - std::numeric_limits&lt;double&gt;::digits10 : 0;
<span class="lineNum">     191 </span>            :     }
<span class="lineNum">     192 </span>            : 
<span class="lineNum">     193 </span>            :     /**
<span class="lineNum">     194 </span>            :      * true if the machine is big-endian.
<span class="lineNum">     195 </span>            :      **********************************************************************/
<span class="lineNum">     196 </span>            :     static const bool bigendian = GEOGRAPHICLIB_WORDS_BIGENDIAN;
<span class="lineNum">     197 </span>            : 
<span class="lineNum">     198 </span>            :     /**
<span class="lineNum">     199 </span>            :      * @tparam T the type of the returned value.
<span class="lineNum">     200 </span>            :      * @return &amp;pi;.
<span class="lineNum">     201 </span>            :      **********************************************************************/
<span class="lineNum">     202 </span>            :     template&lt;typename T&gt; static T pi() {
<span class="lineNum">     203 </span>            :       using std::atan2;
<span class="lineNum">     204 </span>            :       static const T pi = atan2(T(0), T(-1));
<span class="lineNum">     205 </span>            :       return pi;
<span class="lineNum">     206 </span>            :     }
<span class="lineNum">     207 </span>            :     /**
<span class="lineNum">     208 </span>            :      * A synonym for pi&lt;real&gt;().
<span class="lineNum">     209 </span>            :      **********************************************************************/
<span class="lineNum">     210 </span>            :     static real pi() { return pi&lt;real&gt;(); }
<span class="lineNum">     211 </span>            : 
<span class="lineNum">     212 </span>            :     /**
<span class="lineNum">     213 </span>            :      * @tparam T the type of the returned value.
<a name="214"><span class="lineNum">     214 </span>            :      * @return the number of radians in a degree.</a>
<span class="lineNum">     215 </span>            :      **********************************************************************/
<span class="lineNum">     216 </span><span class="lineCov">       1582 :     template&lt;typename T&gt; static T degree() {</span>
<span class="lineNum">     217 </span><span class="lineCov">       1582 :       static const T degree = pi&lt;T&gt;() / 180;</span>
<span class="lineNum">     218 </span><span class="lineCov">       1582 :       return degree;</span>
<span class="lineNum">     219 </span>            :     }
<span class="lineNum">     220 </span>            :     /**
<span class="lineNum">     221 </span>            :      * A synonym for degree&lt;real&gt;().
<span class="lineNum">     222 </span>            :      **********************************************************************/
<span class="lineNum">     223 </span><span class="lineCov">       1582 :     static real degree() { return degree&lt;real&gt;(); }</span>
<span class="lineNum">     224 </span>            : 
<span class="lineNum">     225 </span>            :     /**
<span class="lineNum">     226 </span>            :      * Square a number.
<span class="lineNum">     227 </span>            :      *
<span class="lineNum">     228 </span>            :      * @tparam T the type of the argument and the returned value.
<span class="lineNum">     229 </span>            :      * @param[in] x
<span class="lineNum">     230 </span>            :      * @return &lt;i&gt;x&lt;/i&gt;&lt;sup&gt;2&lt;/sup&gt;.
<span class="lineNum">     231 </span>            :      **********************************************************************/
<span class="lineNum">     232 </span>            :     template&lt;typename T&gt; static T sq(T x)
<span class="lineNum">     233 </span><span class="lineCov">       3543 :     { return x * x; }</span>
<span class="lineNum">     234 </span>            : 
<span class="lineNum">     235 </span>            :     /**
<span class="lineNum">     236 </span>            :      * The hypotenuse function avoiding underflow and overflow.
<span class="lineNum">     237 </span>            :      *
<span class="lineNum">     238 </span>            :      * @tparam T the type of the arguments and the returned value.
<span class="lineNum">     239 </span>            :      * @param[in] x
<span class="lineNum">     240 </span>            :      * @param[in] y
<span class="lineNum">     241 </span>            :      * @return sqrt(&lt;i&gt;x&lt;/i&gt;&lt;sup&gt;2&lt;/sup&gt; + &lt;i&gt;y&lt;/i&gt;&lt;sup&gt;2&lt;/sup&gt;).
<span class="lineNum">     242 </span>            :      **********************************************************************/
<span class="lineNum">     243 </span>            :     template&lt;typename T&gt; static T hypot(T x, T y) {
<span class="lineNum">     244 </span>            : #if GEOGRAPHICLIB_CXX11_MATH
<span class="lineNum">     245 </span><span class="lineCov">       2675 :       using std::hypot; return hypot(x, y);</span>
<span class="lineNum">     246 </span>            : #else
<span class="lineNum">     247 </span>            :       using std::abs; using std::sqrt;
<span class="lineNum">     248 </span>            :       x = abs(x); y = abs(y);
<span class="lineNum">     249 </span>            :       if (x &lt; y) std::swap(x, y); // Now x &gt;= y &gt;= 0
<span class="lineNum">     250 </span>            :       y /= (x ? x : 1);
<span class="lineNum">     251 </span>            :       return x * sqrt(1 + y * y);
<span class="lineNum">     252 </span>            :       // For an alternative (square-root free) method see
<span class="lineNum">     253 </span>            :       // C. Moler and D. Morrision (1983) https://doi.org/10.1147/rd.276.0577
<span class="lineNum">     254 </span>            :       // and A. A. Dubrulle (1983) https://doi.org/10.1147/rd.276.0582
<span class="lineNum">     255 </span>            : #endif
<span class="lineNum">     256 </span>            :     }
<span class="lineNum">     257 </span>            : 
<span class="lineNum">     258 </span>            :     /**
<span class="lineNum">     259 </span>            :      * exp(\e x) &amp;minus; 1 accurate near \e x = 0.
<span class="lineNum">     260 </span>            :      *
<span class="lineNum">     261 </span>            :      * @tparam T the type of the argument and the returned value.
<span class="lineNum">     262 </span>            :      * @param[in] x
<span class="lineNum">     263 </span>            :      * @return exp(\e x) &amp;minus; 1.
<span class="lineNum">     264 </span>            :      **********************************************************************/
<span class="lineNum">     265 </span>            :     template&lt;typename T&gt; static T expm1(T x) {
<span class="lineNum">     266 </span>            : #if GEOGRAPHICLIB_CXX11_MATH
<span class="lineNum">     267 </span><span class="lineCov">          9 :       using std::expm1; return expm1(x);</span>
<span class="lineNum">     268 </span>            : #else
<span class="lineNum">     269 </span>            :       using std::exp; using std::abs; using std::log;
<span class="lineNum">     270 </span>            :       GEOGRAPHICLIB_VOLATILE T
<span class="lineNum">     271 </span>            :         y = exp(x),
<span class="lineNum">     272 </span>            :         z = y - 1;
<span class="lineNum">     273 </span>            :       // The reasoning here is similar to that for log1p.  The expression
<span class="lineNum">     274 </span>            :       // mathematically reduces to exp(x) - 1, and the factor z/log(y) = (y -
<span class="lineNum">     275 </span>            :       // 1)/log(y) is a slowly varying quantity near y = 1 and is accurately
<span class="lineNum">     276 </span>            :       // computed.
<span class="lineNum">     277 </span>            :       return abs(x) &gt; 1 ? z : (z == 0 ? x : x * z / log(y));
<span class="lineNum">     278 </span>            : #endif
<span class="lineNum">     279 </span>            :     }
<span class="lineNum">     280 </span>            : 
<span class="lineNum">     281 </span>            :     /**
<span class="lineNum">     282 </span>            :      * log(1 + \e x) accurate near \e x = 0.
<span class="lineNum">     283 </span>            :      *
<span class="lineNum">     284 </span>            :      * @tparam T the type of the argument and the returned value.
<span class="lineNum">     285 </span>            :      * @param[in] x
<span class="lineNum">     286 </span>            :      * @return log(1 + \e x).
<span class="lineNum">     287 </span>            :      **********************************************************************/
<span class="lineNum">     288 </span>            :     template&lt;typename T&gt; static T log1p(T x) {
<span class="lineNum">     289 </span>            : #if GEOGRAPHICLIB_CXX11_MATH
<span class="lineNum">     290 </span><span class="lineCov">          8 :       using std::log1p; return log1p(x);</span>
<span class="lineNum">     291 </span>            : #else
<span class="lineNum">     292 </span>            :       using std::log;
<span class="lineNum">     293 </span>            :       GEOGRAPHICLIB_VOLATILE T
<span class="lineNum">     294 </span>            :         y = 1 + x,
<span class="lineNum">     295 </span>            :         z = y - 1;
<span class="lineNum">     296 </span>            :       // Here's the explanation for this magic: y = 1 + z, exactly, and z
<span class="lineNum">     297 </span>            :       // approx x, thus log(y)/z (which is nearly constant near z = 0) returns
<span class="lineNum">     298 </span>            :       // a good approximation to the true log(1 + x)/x.  The multiplication x *
<span class="lineNum">     299 </span>            :       // (log(y)/z) introduces little additional error.
<span class="lineNum">     300 </span>            :       return z == 0 ? x : x * log(y) / z;
<span class="lineNum">     301 </span>            : #endif
<span class="lineNum">     302 </span>            :     }
<span class="lineNum">     303 </span>            : 
<span class="lineNum">     304 </span>            :     /**
<span class="lineNum">     305 </span>            :      * The inverse hyperbolic sine function.
<span class="lineNum">     306 </span>            :      *
<span class="lineNum">     307 </span>            :      * @tparam T the type of the argument and the returned value.
<span class="lineNum">     308 </span>            :      * @param[in] x
<span class="lineNum">     309 </span>            :      * @return asinh(\e x).
<span class="lineNum">     310 </span>            :      **********************************************************************/
<span class="lineNum">     311 </span>            :     template&lt;typename T&gt; static T asinh(T x) {
<span class="lineNum">     312 </span>            : #if GEOGRAPHICLIB_CXX11_MATH
<span class="lineNum">     313 </span><span class="lineCov">        178 :       using std::asinh; return asinh(x);</span>
<span class="lineNum">     314 </span>            : #else
<span class="lineNum">     315 </span>            :       using std::abs; T y = abs(x); // Enforce odd parity
<span class="lineNum">     316 </span>            :       y = log1p(y * (1 + y/(hypot(T(1), y) + 1)));
<span class="lineNum">     317 </span>            :       return x &lt; 0 ? -y : y;
<span class="lineNum">     318 </span>            : #endif
<span class="lineNum">     319 </span>            :     }
<span class="lineNum">     320 </span>            : 
<span class="lineNum">     321 </span>            :     /**
<span class="lineNum">     322 </span>            :      * The inverse hyperbolic tangent function.
<span class="lineNum">     323 </span>            :      *
<span class="lineNum">     324 </span>            :      * @tparam T the type of the argument and the returned value.
<span class="lineNum">     325 </span>            :      * @param[in] x
<span class="lineNum">     326 </span>            :      * @return atanh(\e x).
<span class="lineNum">     327 </span>            :      **********************************************************************/
<span class="lineNum">     328 </span>            :     template&lt;typename T&gt; static T atanh(T x) {
<span class="lineNum">     329 </span>            : #if GEOGRAPHICLIB_CXX11_MATH
<span class="lineNum">     330 </span><span class="lineCov">        595 :       using std::atanh; return atanh(x);</span>
<span class="lineNum">     331 </span>            : #else
<span class="lineNum">     332 </span>            :       using std::abs; T y = abs(x); // Enforce odd parity
<span class="lineNum">     333 </span>            :       y = log1p(2 * y/(1 - y))/2;
<span class="lineNum">     334 </span>            :       return x &lt; 0 ? -y : y;
<span class="lineNum">     335 </span>            : #endif
<span class="lineNum">     336 </span>            :     }
<span class="lineNum">     337 </span>            : 
<span class="lineNum">     338 </span>            :     /**
<span class="lineNum">     339 </span>            :      * The cube root function.
<span class="lineNum">     340 </span>            :      *
<span class="lineNum">     341 </span>            :      * @tparam T the type of the argument and the returned value.
<span class="lineNum">     342 </span>            :      * @param[in] x
<span class="lineNum">     343 </span>            :      * @return the real cube root of \e x.
<span class="lineNum">     344 </span>            :      **********************************************************************/
<span class="lineNum">     345 </span>            :     template&lt;typename T&gt; static T cbrt(T x) {
<span class="lineNum">     346 </span>            : #if GEOGRAPHICLIB_CXX11_MATH
<span class="lineNum">     347 </span><span class="lineCov">          4 :       using std::cbrt; return cbrt(x);</span>
<span class="lineNum">     348 </span>            : #else
<span class="lineNum">     349 </span>            :       using std::abs; using std::pow;
<span class="lineNum">     350 </span>            :       T y = pow(abs(x), 1/T(3)); // Return the real cube root
<span class="lineNum">     351 </span>            :       return x &lt; 0 ? -y : y;
<span class="lineNum">     352 </span>            : #endif
<span class="lineNum">     353 </span>            :     }
<span class="lineNum">     354 </span>            : 
<span class="lineNum">     355 </span>            :     /**
<span class="lineNum">     356 </span>            :      * Fused multiply and add.
<span class="lineNum">     357 </span>            :      *
<span class="lineNum">     358 </span>            :      * @tparam T the type of the arguments and the returned value.
<span class="lineNum">     359 </span>            :      * @param[in] x
<span class="lineNum">     360 </span>            :      * @param[in] y
<span class="lineNum">     361 </span>            :      * @param[in] z
<span class="lineNum">     362 </span>            :      * @return &lt;i&gt;xy&lt;/i&gt; + &lt;i&gt;z&lt;/i&gt;, correctly rounded (on those platforms with
<span class="lineNum">     363 </span>            :      *   support for the &lt;code&gt;fma&lt;/code&gt; instruction).
<span class="lineNum">     364 </span>            :      *
<span class="lineNum">     365 </span>            :      * On platforms without the &lt;code&gt;fma&lt;/code&gt; instruction, no attempt is
<span class="lineNum">     366 </span>            :      * made to improve on the result of a rounded multiplication followed by a
<span class="lineNum">     367 </span>            :      * rounded addition.
<span class="lineNum">     368 </span>            :      **********************************************************************/
<span class="lineNum">     369 </span>            :     template&lt;typename T&gt; static T fma(T x, T y, T z) {
<span class="lineNum">     370 </span>            : #if GEOGRAPHICLIB_CXX11_MATH
<span class="lineNum">     371 </span><span class="lineNoCov">          0 :       using std::fma; return fma(x, y, z);</span>
<span class="lineNum">     372 </span>            : #else
<span class="lineNum">     373 </span>            :       return x * y + z;
<span class="lineNum">     374 </span>            : #endif
<span class="lineNum">     375 </span>            :     }
<span class="lineNum">     376 </span>            : 
<span class="lineNum">     377 </span>            :     /**
<span class="lineNum">     378 </span>            :      * Normalize a two-vector.
<span class="lineNum">     379 </span>            :      *
<span class="lineNum">     380 </span>            :      * @tparam T the type of the argument and the returned value.
<span class="lineNum">     381 </span>            :      * @param[in,out] x on output set to &lt;i&gt;x&lt;/i&gt;/hypot(&lt;i&gt;x&lt;/i&gt;, &lt;i&gt;y&lt;/i&gt;).
<span class="lineNum">     382 </span>            :      * @param[in,out] y on output set to &lt;i&gt;y&lt;/i&gt;/hypot(&lt;i&gt;x&lt;/i&gt;, &lt;i&gt;y&lt;/i&gt;).
<span class="lineNum">     383 </span>            :      **********************************************************************/
<span class="lineNum">     384 </span>            :     template&lt;typename T&gt; static void norm(T&amp; x, T&amp; y)
<span class="lineNum">     385 </span><span class="lineCov">       1573 :     { T h = hypot(x, y); x /= h; y /= h; }</span>
<span class="lineNum">     386 </span>            : 
<span class="lineNum">     387 </span>            :     /**
<span class="lineNum">     388 </span>            :      * The error-free sum of two numbers.
<span class="lineNum">     389 </span>            :      *
<span class="lineNum">     390 </span>            :      * @tparam T the type of the argument and the returned value.
<span class="lineNum">     391 </span>            :      * @param[in] u
<span class="lineNum">     392 </span>            :      * @param[in] v
<span class="lineNum">     393 </span>            :      * @param[out] t the exact error given by (\e u + \e v) - \e s.
<span class="lineNum">     394 </span>            :      * @return \e s = round(\e u + \e v).
<span class="lineNum">     395 </span>            :      *
<span class="lineNum">     396 </span>            :      * See D. E. Knuth, TAOCP, Vol 2, 4.2.2, Theorem B.  (Note that \e t can be
<a name="397"><span class="lineNum">     397 </span>            :      * the same as one of the first two arguments.)</a>
<span class="lineNum">     398 </span>            :      **********************************************************************/
<span class="lineNum">     399 </span><span class="lineCov">        646 :     template&lt;typename T&gt; static T sum(T u, T v, T&amp; t) {</span>
<span class="lineNum">     400 </span><span class="lineCov">        646 :       GEOGRAPHICLIB_VOLATILE T s = u + v;</span>
<span class="lineNum">     401 </span><span class="lineCov">        646 :       GEOGRAPHICLIB_VOLATILE T up = s - v;</span>
<span class="lineNum">     402 </span><span class="lineCov">        646 :       GEOGRAPHICLIB_VOLATILE T vpp = s - up;</span>
<span class="lineNum">     403 </span><span class="lineCov">        646 :       up -= u;</span>
<span class="lineNum">     404 </span><span class="lineCov">        646 :       vpp -= v;</span>
<span class="lineNum">     405 </span><span class="lineCov">        646 :       t = -(up + vpp);</span>
<span class="lineNum">     406 </span>            :       // u + v =       s      + t
<span class="lineNum">     407 </span>            :       //       = round(u + v) + t
<span class="lineNum">     408 </span><span class="lineCov">        646 :       return s;</span>
<span class="lineNum">     409 </span>            :     }
<span class="lineNum">     410 </span>            : 
<span class="lineNum">     411 </span>            :     /**
<span class="lineNum">     412 </span>            :      * Evaluate a polynomial.
<span class="lineNum">     413 </span>            :      *
<span class="lineNum">     414 </span>            :      * @tparam T the type of the arguments and returned value.
<span class="lineNum">     415 </span>            :      * @param[in] N the order of the polynomial.
<span class="lineNum">     416 </span>            :      * @param[in] p the coefficient array (of size \e N + 1).
<span class="lineNum">     417 </span>            :      * @param[in] x the variable.
<span class="lineNum">     418 </span>            :      * @return the value of the polynomial.
<span class="lineNum">     419 </span>            :      *
<span class="lineNum">     420 </span>            :      * Evaluate &lt;i&gt;y&lt;/i&gt; = &amp;sum;&lt;sub&gt;&lt;i&gt;n&lt;/i&gt;=0..&lt;i&gt;N&lt;/i&gt;&lt;/sub&gt;
<span class="lineNum">     421 </span>            :      * &lt;i&gt;p&lt;/i&gt;&lt;sub&gt;&lt;i&gt;n&lt;/i&gt;&lt;/sub&gt; &lt;i&gt;x&lt;/i&gt;&lt;sup&gt;&lt;i&gt;N&lt;/i&gt;&amp;minus;&lt;i&gt;n&lt;/i&gt;&lt;/sup&gt;.
<span class="lineNum">     422 </span>            :      * Return 0 if \e N &amp;lt; 0.  Return &lt;i&gt;p&lt;/i&gt;&lt;sub&gt;0&lt;/sub&gt;, if \e N = 0 (even
<span class="lineNum">     423 </span>            :      * if \e x is infinite or a nan).  The evaluation uses Horner's method.
<span class="lineNum">     424 </span>            :      **********************************************************************/
<span class="lineNum">     425 </span>            :     template&lt;typename T&gt; static T polyval(int N, const T p[], T x)
<span class="lineNum">     426 </span>            :     // This used to employ Math::fma; but that's too slow and it seemed not to
<span class="lineNum">     427 </span>            :     // improve the accuracy noticeably.  This might change when there's direct
<span class="lineNum">     428 </span>            :     // hardware support for fma.
<span class="lineNum">     429 </span><span class="lineCov">      54437 :     { T y = N &lt; 0 ? 0 : *p++; while (--N &gt;= 0) y = y * x + *p++; return y; }</span>
<span class="lineNum">     430 </span>            : 
<span class="lineNum">     431 </span>            :     /**
<span class="lineNum">     432 </span>            :      * Normalize an angle.
<span class="lineNum">     433 </span>            :      *
<span class="lineNum">     434 </span>            :      * @tparam T the type of the argument and returned value.
<span class="lineNum">     435 </span>            :      * @param[in] x the angle in degrees.
<span class="lineNum">     436 </span>            :      * @return the angle reduced to the range([&amp;minus;180&amp;deg;, 180&amp;deg;].
<span class="lineNum">     437 </span>            :      *
<span class="lineNum">     438 </span>            :      * The range of \e x is unrestricted.
<span class="lineNum">     439 </span>            :      **********************************************************************/
<span class="lineNum">     440 </span>            :     template&lt;typename T&gt; static T AngNormalize(T x) {
<span class="lineNum">     441 </span>            : #if GEOGRAPHICLIB_CXX11_MATH &amp;&amp; GEOGRAPHICLIB_PRECISION != 4
<span class="lineNum">     442 </span>            :       using std::remainder;
<span class="lineNum">     443 </span><span class="lineCov">        667 :       x = remainder(x, T(360)); return x != -180 ? x : 180;</span>
<span class="lineNum">     444 </span>            : #else
<span class="lineNum">     445 </span>            :       using std::fmod;
<span class="lineNum">     446 </span>            :       T y = fmod(x, T(360));
<span class="lineNum">     447 </span>            : #if defined(_MSC_VER) &amp;&amp; _MSC_VER &lt; 1900
<span class="lineNum">     448 </span>            :       // Before version 14 (2015), Visual Studio had problems dealing
<span class="lineNum">     449 </span>            :       // with -0.0.  Specifically
<span class="lineNum">     450 </span>            :       //   VC 10,11,12 and 32-bit compile: fmod(-0.0, 360.0) -&gt; +0.0
<span class="lineNum">     451 </span>            :       // sincosd has a similar fix.
<span class="lineNum">     452 </span>            :       // python 2.7 on Windows 32-bit machines has the same problem.
<span class="lineNum">     453 </span>            :       if (x == 0) y = x;
<span class="lineNum">     454 </span>            : #endif
<span class="lineNum">     455 </span>            :       return y &lt;= -180 ? y + 360 : (y &lt;= 180 ? y : y - 360);
<span class="lineNum">     456 </span>            : #endif
<span class="lineNum">     457 </span>            :     }
<span class="lineNum">     458 </span>            : 
<span class="lineNum">     459 </span>            :     /**
<span class="lineNum">     460 </span>            :      * Normalize a latitude.
<span class="lineNum">     461 </span>            :      *
<span class="lineNum">     462 </span>            :      * @tparam T the type of the argument and returned value.
<span class="lineNum">     463 </span>            :      * @param[in] x the angle in degrees.
<span class="lineNum">     464 </span>            :      * @return x if it is in the range [&amp;minus;90&amp;deg;, 90&amp;deg;], otherwise
<span class="lineNum">     465 </span>            :      *   return NaN.
<span class="lineNum">     466 </span>            :      **********************************************************************/
<span class="lineNum">     467 </span>            :     template&lt;typename T&gt; static T LatFix(T x)
<span class="lineNum">     468 </span><span class="lineCov">        395 :     { using std::abs; return abs(x) &gt; 90 ? NaN&lt;T&gt;() : x; }</span>
<span class="lineNum">     469 </span>            : 
<span class="lineNum">     470 </span>            :     /**
<span class="lineNum">     471 </span>            :      * The exact difference of two angles reduced to
<span class="lineNum">     472 </span>            :      * (&amp;minus;180&amp;deg;, 180&amp;deg;].
<span class="lineNum">     473 </span>            :      *
<span class="lineNum">     474 </span>            :      * @tparam T the type of the arguments and returned value.
<span class="lineNum">     475 </span>            :      * @param[in] x the first angle in degrees.
<span class="lineNum">     476 </span>            :      * @param[in] y the second angle in degrees.
<span class="lineNum">     477 </span>            :      * @param[out] e the error term in degrees.
<span class="lineNum">     478 </span>            :      * @return \e d, the truncated value of \e y &amp;minus; \e x.
<span class="lineNum">     479 </span>            :      *
<span class="lineNum">     480 </span>            :      * This computes \e z = \e y &amp;minus; \e x exactly, reduced to
<span class="lineNum">     481 </span>            :      * (&amp;minus;180&amp;deg;, 180&amp;deg;]; and then sets \e z = \e d + \e e where \e d
<span class="lineNum">     482 </span>            :      * is the nearest representable number to \e z and \e e is the truncation
<span class="lineNum">     483 </span>            :      * error.  If \e d = &amp;minus;180, then \e e &amp;gt; 0; If \e d = 180, then \e e
<a name="484"><span class="lineNum">     484 </span>            :      * &amp;le; 0.</a>
<span class="lineNum">     485 </span>            :      **********************************************************************/
<span class="lineNum">     486 </span><span class="lineCov">        213 :     template&lt;typename T&gt; static T AngDiff(T x, T y, T&amp; e) {</span>
<span class="lineNum">     487 </span>            : #if GEOGRAPHICLIB_CXX11_MATH &amp;&amp; GEOGRAPHICLIB_PRECISION != 4
<span class="lineNum">     488 </span>            :       using std::remainder;
<span class="lineNum">     489 </span><span class="lineCov">        213 :       T t, d = AngNormalize(sum(remainder(-x, T(360)),</span>
<span class="lineNum">     490 </span>            :                                 remainder( y, T(360)), t));
<span class="lineNum">     491 </span>            : #else
<span class="lineNum">     492 </span>            :       T t, d = AngNormalize(sum(AngNormalize(-x), AngNormalize(y), t));
<span class="lineNum">     493 </span>            : #endif
<span class="lineNum">     494 </span>            :       // Here y - x = d + t (mod 360), exactly, where d is in (-180,180] and
<span class="lineNum">     495 </span>            :       // abs(t) &lt;= eps (eps = 2^-45 for doubles).  The only case where the
<span class="lineNum">     496 </span>            :       // addition of t takes the result outside the range (-180,180] is d = 180
<span class="lineNum">     497 </span>            :       // and t &gt; 0.  The case, d = -180 + eps, t = -eps, can't happen, since
<span class="lineNum">     498 </span>            :       // sum would have returned the exact result in such a case (i.e., given t
<span class="lineNum">     499 </span>            :       // = 0).
<span class="lineNum">     500 </span><span class="lineCov">        213 :       return sum(d == 180 &amp;&amp; t &gt; 0 ? -180 : d, t, e);</span>
<span class="lineNum">     501 </span>            :     }
<span class="lineNum">     502 </span>            : 
<span class="lineNum">     503 </span>            :     /**
<span class="lineNum">     504 </span>            :      * Difference of two angles reduced to [&amp;minus;180&amp;deg;, 180&amp;deg;]
<span class="lineNum">     505 </span>            :      *
<span class="lineNum">     506 </span>            :      * @tparam T the type of the arguments and returned value.
<span class="lineNum">     507 </span>            :      * @param[in] x the first angle in degrees.
<span class="lineNum">     508 </span>            :      * @param[in] y the second angle in degrees.
<span class="lineNum">     509 </span>            :      * @return \e y &amp;minus; \e x, reduced to the range [&amp;minus;180&amp;deg;,
<span class="lineNum">     510 </span>            :      *   180&amp;deg;].
<span class="lineNum">     511 </span>            :      *
<span class="lineNum">     512 </span>            :      * The result is equivalent to computing the difference exactly, reducing
<span class="lineNum">     513 </span>            :      * it to (&amp;minus;180&amp;deg;, 180&amp;deg;] and rounding the result.  Note that
<span class="lineNum">     514 </span>            :      * this prescription allows &amp;minus;180&amp;deg; to be returned (e.g., if \e x
<span class="lineNum">     515 </span>            :      * is tiny and negative and \e y = 180&amp;deg;).
<span class="lineNum">     516 </span>            :      **********************************************************************/
<span class="lineNum">     517 </span>            :     template&lt;typename T&gt; static T AngDiff(T x, T y)
<span class="lineNum">     518 </span><span class="lineCov">        103 :     { T e; return AngDiff(x, y, e); }</span>
<span class="lineNum">     519 </span>            : 
<span class="lineNum">     520 </span>            :     /**
<span class="lineNum">     521 </span>            :      * Coarsen a value close to zero.
<span class="lineNum">     522 </span>            :      *
<span class="lineNum">     523 </span>            :      * @tparam T the type of the argument and returned value.
<span class="lineNum">     524 </span>            :      * @param[in] x
<span class="lineNum">     525 </span>            :      * @return the coarsened value.
<span class="lineNum">     526 </span>            :      *
<span class="lineNum">     527 </span>            :      * The makes the smallest gap in \e x = 1/16 - nextafter(1/16, 0) =
<span class="lineNum">     528 </span>            :      * 1/2&lt;sup&gt;57&lt;/sup&gt; for reals = 0.7 pm on the earth if \e x is an angle in
<span class="lineNum">     529 </span>            :      * degrees.  (This is about 1000 times more resolution than we get with
<span class="lineNum">     530 </span>            :      * angles around 90&amp;deg;.)  We use this to avoid having to deal with near
<span class="lineNum">     531 </span>            :      * singular cases when \e x is non-zero but tiny (e.g.,
<span class="lineNum">     532 </span>            :      * 10&lt;sup&gt;&amp;minus;200&lt;/sup&gt;).  This converts -0 to +0; however tiny negative
<span class="lineNum">     533 </span>            :      * numbers get converted to -0.
<span class="lineNum">     534 </span>            :      **********************************************************************/
<span class="lineNum">     535 </span>            :     template&lt;typename T&gt; static T AngRound(T x) {
<span class="lineNum">     536 </span>            :       using std::abs;
<span class="lineNum">     537 </span>            :       static const T z = 1/T(16);
<span class="lineNum">     538 </span><span class="lineCov">        482 :       if (x == 0) return 0;</span>
<span class="lineNum">     539 </span><span class="lineCov">        393 :       GEOGRAPHICLIB_VOLATILE T y = abs(x);</span>
<span class="lineNum">     540 </span>            :       // The compiler mustn't &quot;simplify&quot; z - (z - y) to y
<span class="lineNum">     541 </span><span class="lineCov">        393 :       y = y &lt; z ? z - (z - y) : y;</span>
<span class="lineNum">     542 </span><span class="lineCov">        393 :       return x &lt; 0 ? -y : y;</span>
<span class="lineNum">     543 </span>            :     }
<span class="lineNum">     544 </span>            : 
<span class="lineNum">     545 </span>            :     /**
<span class="lineNum">     546 </span>            :      * Evaluate the sine and cosine function with the argument in degrees
<span class="lineNum">     547 </span>            :      *
<span class="lineNum">     548 </span>            :      * @tparam T the type of the arguments.
<span class="lineNum">     549 </span>            :      * @param[in] x in degrees.
<span class="lineNum">     550 </span>            :      * @param[out] sinx sin(&lt;i&gt;x&lt;/i&gt;).
<span class="lineNum">     551 </span>            :      * @param[out] cosx cos(&lt;i&gt;x&lt;/i&gt;).
<span class="lineNum">     552 </span>            :      *
<span class="lineNum">     553 </span>            :      * The results obey exactly the elementary properties of the trigonometric
<span class="lineNum">     554 </span>            :      * functions, e.g., sin 9&amp;deg; = cos 81&amp;deg; = &amp;minus; sin 123456789&amp;deg;.
<span class="lineNum">     555 </span>            :      * If x = &amp;minus;0, then \e sinx = &amp;minus;0; this is the only case where
<a name="556"><span class="lineNum">     556 </span>            :      * &amp;minus;0 is returned.</a>
<span class="lineNum">     557 </span>            :      **********************************************************************/
<span class="lineNum">     558 </span><span class="lineCov">        647 :     template&lt;typename T&gt; static void sincosd(T x, T&amp; sinx, T&amp; cosx) {</span>
<span class="lineNum">     559 </span>            :       // In order to minimize round-off errors, this function exactly reduces
<span class="lineNum">     560 </span>            :       // the argument to the range [-45, 45] before converting it to radians.
<span class="lineNum">     561 </span>            :       using std::sin; using std::cos;
<span class="lineNum">     562 </span>            :       T r; int q;
<span class="lineNum">     563 </span>            : #if GEOGRAPHICLIB_CXX11_MATH &amp;&amp; GEOGRAPHICLIB_PRECISION &lt;= 3 &amp;&amp; \
<span class="lineNum">     564 </span>            :   !defined(__GNUC__)
<span class="lineNum">     565 </span>            :       // Disable for gcc because of bug in glibc version &lt; 2.22, see
<span class="lineNum">     566 </span>            :       //   https://sourceware.org/bugzilla/show_bug.cgi?id=17569
<span class="lineNum">     567 </span>            :       // Once this fix is widely deployed, should insert a runtime test for the
<span class="lineNum">     568 </span>            :       // glibc version number.  For example
<span class="lineNum">     569 </span>            :       //   #include &lt;gnu/libc-version.h&gt;
<span class="lineNum">     570 </span>            :       //   std::string version(gnu_get_libc_version()); =&gt; &quot;2.22&quot;
<span class="lineNum">     571 </span>            :       using std::remquo;
<span class="lineNum">     572 </span>            :       r = remquo(x, T(90), &amp;q);
<span class="lineNum">     573 </span>            : #else
<span class="lineNum">     574 </span>            :       using std::fmod; using std::floor;
<span class="lineNum">     575 </span><span class="lineCov">        647 :       r = fmod(x, T(360));</span>
<span class="lineNum">     576 </span><span class="lineCov">        647 :       q = int(floor(r / 90 + T(0.5)));</span>
<span class="lineNum">     577 </span><span class="lineCov">        647 :       r -= 90 * q;</span>
<span class="lineNum">     578 </span>            : #endif
<span class="lineNum">     579 </span>            :       // now abs(r) &lt;= 45
<span class="lineNum">     580 </span><span class="lineCov">        647 :       r *= degree();</span>
<span class="lineNum">     581 </span>            :       // Possibly could call the gnu extension sincos
<span class="lineNum">     582 </span><span class="lineCov">        647 :       T s = sin(r), c = cos(r);</span>
<span class="lineNum">     583 </span>            : #if defined(_MSC_VER) &amp;&amp; _MSC_VER &lt; 1900
<span class="lineNum">     584 </span>            :       // Before version 14 (2015), Visual Studio had problems dealing
<span class="lineNum">     585 </span>            :       // with -0.0.  Specifically
<span class="lineNum">     586 </span>            :       //   VC 10,11,12 and 32-bit compile: fmod(-0.0, 360.0) -&gt; +0.0
<span class="lineNum">     587 </span>            :       //   VC 12       and 64-bit compile:  sin(-0.0)        -&gt; +0.0
<span class="lineNum">     588 </span>            :       // AngNormalize has a similar fix.
<span class="lineNum">     589 </span>            :       // python 2.7 on Windows 32-bit machines has the same problem.
<span class="lineNum">     590 </span>            :       if (x == 0) s = x;
<span class="lineNum">     591 </span>            : #endif
<span class="lineNum">     592 </span><span class="lineCov">        647 :       switch (unsigned(q) &amp; 3U) {</span>
<span class="lineNum">     593 </span><span class="lineCov">        419 :       case 0U: sinx =  s; cosx =  c; break;</span>
<span class="lineNum">     594 </span><span class="lineCov">        144 :       case 1U: sinx =  c; cosx = -s; break;</span>
<span class="lineNum">     595 </span><span class="lineCov">          8 :       case 2U: sinx = -s; cosx = -c; break;</span>
<span class="lineNum">     596 </span><span class="lineCov">         76 :       default: sinx = -c; cosx =  s; break; // case 3U</span>
<span class="lineNum">     597 </span>            :       }
<span class="lineNum">     598 </span>            :       // Set sign of 0 results.  -0 only produced for sin(-0)
<span class="lineNum">     599 </span><span class="lineCov">        647 :       if (x != 0) { sinx += T(0); cosx += T(0); }</span>
<span class="lineNum">     600 </span><span class="lineCov">        647 :     }</span>
<span class="lineNum">     601 </span>            : 
<span class="lineNum">     602 </span>            :     /**
<span class="lineNum">     603 </span>            :      * Evaluate the sine function with the argument in degrees
<span class="lineNum">     604 </span>            :      *
<span class="lineNum">     605 </span>            :      * @tparam T the type of the argument and the returned value.
<span class="lineNum">     606 </span>            :      * @param[in] x in degrees.
<a name="607"><span class="lineNum">     607 </span>            :      * @return sin(&lt;i&gt;x&lt;/i&gt;).</a>
<span class="lineNum">     608 </span>            :      **********************************************************************/
<span class="lineNum">     609 </span><span class="lineNoCov">          0 :     template&lt;typename T&gt; static T sind(T x) {</span>
<span class="lineNum">     610 </span>            :       // See sincosd
<span class="lineNum">     611 </span>            :       using std::sin; using std::cos;
<span class="lineNum">     612 </span>            :       T r; int q;
<span class="lineNum">     613 </span>            : #if GEOGRAPHICLIB_CXX11_MATH &amp;&amp; GEOGRAPHICLIB_PRECISION &lt;= 3 &amp;&amp; \
<span class="lineNum">     614 </span>            :   !defined(__GNUC__)
<span class="lineNum">     615 </span>            :       using std::remquo;
<span class="lineNum">     616 </span>            :       r = remquo(x, T(90), &amp;q);
<span class="lineNum">     617 </span>            : #else
<span class="lineNum">     618 </span>            :       using std::fmod; using std::floor;
<span class="lineNum">     619 </span><span class="lineNoCov">          0 :       r = fmod(x, T(360));</span>
<span class="lineNum">     620 </span><span class="lineNoCov">          0 :       q = int(floor(r / 90 + T(0.5)));</span>
<span class="lineNum">     621 </span><span class="lineNoCov">          0 :       r -= 90 * q;</span>
<span class="lineNum">     622 </span>            : #endif
<span class="lineNum">     623 </span>            :       // now abs(r) &lt;= 45
<span class="lineNum">     624 </span><span class="lineNoCov">          0 :       r *= degree();</span>
<span class="lineNum">     625 </span><span class="lineNoCov">          0 :       unsigned p = unsigned(q);</span>
<span class="lineNum">     626 </span><span class="lineNoCov">          0 :       r = p &amp; 1U ? cos(r) : sin(r);</span>
<span class="lineNum">     627 </span><span class="lineNoCov">          0 :       if (p &amp; 2U) r = -r;</span>
<span class="lineNum">     628 </span><span class="lineNoCov">          0 :       if (x != 0) r += T(0);</span>
<span class="lineNum">     629 </span><span class="lineNoCov">          0 :       return r;</span>
<span class="lineNum">     630 </span>            :     }
<span class="lineNum">     631 </span>            : 
<span class="lineNum">     632 </span>            :     /**
<span class="lineNum">     633 </span>            :      * Evaluate the cosine function with the argument in degrees
<span class="lineNum">     634 </span>            :      *
<span class="lineNum">     635 </span>            :      * @tparam T the type of the argument and the returned value.
<span class="lineNum">     636 </span>            :      * @param[in] x in degrees.
<span class="lineNum">     637 </span>            :      * @return cos(&lt;i&gt;x&lt;/i&gt;).
<span class="lineNum">     638 </span>            :      **********************************************************************/
<span class="lineNum">     639 </span>            :     template&lt;typename T&gt; static T cosd(T x) {
<span class="lineNum">     640 </span>            :       // See sincosd
<span class="lineNum">     641 </span>            :       using std::sin; using std::cos;
<span class="lineNum">     642 </span>            :       T r; int q;
<span class="lineNum">     643 </span>            : #if GEOGRAPHICLIB_CXX11_MATH &amp;&amp; GEOGRAPHICLIB_PRECISION &lt;= 3 &amp;&amp; \
<span class="lineNum">     644 </span>            :   !defined(__GNUC__)
<span class="lineNum">     645 </span>            :       using std::remquo;
<span class="lineNum">     646 </span>            :       r = remquo(x, T(90), &amp;q);
<span class="lineNum">     647 </span>            : #else
<span class="lineNum">     648 </span>            :       using std::fmod; using std::floor;
<span class="lineNum">     649 </span>            :       r = fmod(x, T(360));
<span class="lineNum">     650 </span>            :       q = int(floor(r / 90 + T(0.5)));
<span class="lineNum">     651 </span>            :       r -= 90 * q;
<span class="lineNum">     652 </span>            : #endif
<span class="lineNum">     653 </span>            :       // now abs(r) &lt;= 45
<span class="lineNum">     654 </span>            :       r *= degree();
<span class="lineNum">     655 </span>            :       unsigned p = unsigned(q + 1);
<span class="lineNum">     656 </span>            :       r = p &amp; 1U ? cos(r) : sin(r);
<span class="lineNum">     657 </span>            :       if (p &amp; 2U) r = -r;
<span class="lineNum">     658 </span>            :       return T(0) + r;
<span class="lineNum">     659 </span>            :     }
<span class="lineNum">     660 </span>            : 
<span class="lineNum">     661 </span>            :     /**
<span class="lineNum">     662 </span>            :      * Evaluate the tangent function with the argument in degrees
<span class="lineNum">     663 </span>            :      *
<span class="lineNum">     664 </span>            :      * @tparam T the type of the argument and the returned value.
<span class="lineNum">     665 </span>            :      * @param[in] x in degrees.
<span class="lineNum">     666 </span>            :      * @return tan(&lt;i&gt;x&lt;/i&gt;).
<span class="lineNum">     667 </span>            :      *
<span class="lineNum">     668 </span>            :      * If \e x = &amp;plusmn;90&amp;deg;, then a suitably large (but finite) value is
<a name="669"><span class="lineNum">     669 </span>            :      * returned.</a>
<span class="lineNum">     670 </span>            :      **********************************************************************/
<span class="lineNum">     671 </span><span class="lineCov">        112 :     template&lt;typename T&gt; static T tand(T x) {</span>
<span class="lineNum">     672 </span><span class="lineCov">        112 :       static const T overflow = 1 / sq(std::numeric_limits&lt;T&gt;::epsilon());</span>
<span class="lineNum">     673 </span>            :       T s, c;
<span class="lineNum">     674 </span><span class="lineCov">        112 :       sincosd(x, s, c);</span>
<span class="lineNum">     675 </span><span class="lineCov">        112 :       return c != 0 ? s / c : (s &lt; 0 ? -overflow : overflow);</span>
<span class="lineNum">     676 </span>            :     }
<span class="lineNum">     677 </span>            : 
<span class="lineNum">     678 </span>            :     /**
<span class="lineNum">     679 </span>            :      * Evaluate the atan2 function with the result in degrees
<span class="lineNum">     680 </span>            :      *
<span class="lineNum">     681 </span>            :      * @tparam T the type of the arguments and the returned value.
<span class="lineNum">     682 </span>            :      * @param[in] y
<span class="lineNum">     683 </span>            :      * @param[in] x
<span class="lineNum">     684 </span>            :      * @return atan2(&lt;i&gt;y&lt;/i&gt;, &lt;i&gt;x&lt;/i&gt;) in degrees.
<span class="lineNum">     685 </span>            :      *
<span class="lineNum">     686 </span>            :      * The result is in the range (&amp;minus;180&amp;deg; 180&amp;deg;].  N.B.,
<span class="lineNum">     687 </span>            :      * atan2d(&amp;plusmn;0, &amp;minus;1) = +180&amp;deg;; atan2d(&amp;minus;&amp;epsilon;,
<span class="lineNum">     688 </span>            :      * &amp;minus;1) = &amp;minus;180&amp;deg;, for &amp;epsilon; positive and tiny;
<a name="689"><span class="lineNum">     689 </span>            :      * atan2d(&amp;plusmn;0, +1) = &amp;plusmn;0&amp;deg;.</a>
<span class="lineNum">     690 </span>            :      **********************************************************************/
<span class="lineNum">     691 </span><span class="lineCov">        516 :     template&lt;typename T&gt; static T atan2d(T y, T x) {</span>
<span class="lineNum">     692 </span>            :       // In order to minimize round-off errors, this function rearranges the
<span class="lineNum">     693 </span>            :       // arguments so that result of atan2 is in the range [-pi/4, pi/4] before
<span class="lineNum">     694 </span>            :       // converting it to degrees and mapping the result to the correct
<span class="lineNum">     695 </span>            :       // quadrant.
<span class="lineNum">     696 </span>            :       using std::atan2; using std::abs;
<span class="lineNum">     697 </span>            :       int q = 0;
<span class="lineNum">     698 </span><span class="lineCov">        516 :       if (abs(y) &gt; abs(x)) { std::swap(x, y); q = 2; }</span>
<span class="lineNum">     699 </span><span class="lineCov">        516 :       if (x &lt; 0) { x = -x; ++q; }</span>
<span class="lineNum">     700 </span>            :       // here x &gt;= 0 and x &gt;= abs(y), so angle is in [-pi/4, pi/4]
<span class="lineNum">     701 </span><span class="lineCov">       1032 :       T ang = atan2(y, x) / degree();</span>
<span class="lineNum">     702 </span><span class="lineCov">        516 :       switch (q) {</span>
<span class="lineNum">     703 </span>            :         // Note that atan2d(-0.0, 1.0) will return -0.  However, we expect that
<span class="lineNum">     704 </span>            :         // atan2d will not be called with y = -0.  If need be, include
<span class="lineNum">     705 </span>            :         //
<span class="lineNum">     706 </span>            :         //   case 0: ang = 0 + ang; break;
<span class="lineNum">     707 </span>            :         //
<span class="lineNum">     708 </span>            :         // and handle mpfr as in AngRound.
<span class="lineNum">     709 </span><span class="lineCov">         41 :       case 1: ang = (y &gt;= 0 ? 180 : -180) - ang; break;</span>
<span class="lineNum">     710 </span><span class="lineCov">        117 :       case 2: ang =  90 - ang; break;</span>
<span class="lineNum">     711 </span><span class="lineCov">          9 :       case 3: ang = -90 + ang; break;</span>
<span class="lineNum">     712 </span>            :       }
<span class="lineNum">     713 </span><span class="lineCov">        516 :       return ang;</span>
<span class="lineNum">     714 </span>            :     }
<span class="lineNum">     715 </span>            : 
<span class="lineNum">     716 </span>            :     /**
<span class="lineNum">     717 </span>            :      * Evaluate the atan function with the result in degrees
<span class="lineNum">     718 </span>            :      *
<span class="lineNum">     719 </span>            :      * @tparam T the type of the argument and the returned value.
<span class="lineNum">     720 </span>            :      * @param[in] x
<span class="lineNum">     721 </span>            :      * @return atan(&lt;i&gt;x&lt;/i&gt;) in degrees.
<span class="lineNum">     722 </span>            :      **********************************************************************/
<span class="lineNum">     723 </span>            :     template&lt;typename T&gt; static T atand(T x)
<span class="lineNum">     724 </span><span class="lineCov">         83 :     { return atan2d(x, T(1)); }</span>
<span class="lineNum">     725 </span>            : 
<span class="lineNum">     726 </span>            :     /**
<span class="lineNum">     727 </span>            :      * Evaluate &lt;i&gt;e&lt;/i&gt; atanh(&lt;i&gt;e x&lt;/i&gt;)
<span class="lineNum">     728 </span>            :      *
<span class="lineNum">     729 </span>            :      * @tparam T the type of the argument and the returned value.
<span class="lineNum">     730 </span>            :      * @param[in] x
<span class="lineNum">     731 </span>            :      * @param[in] es the signed eccentricity =  sign(&lt;i&gt;e&lt;/i&gt;&lt;sup&gt;2&lt;/sup&gt;)
<span class="lineNum">     732 </span>            :      *    sqrt(|&lt;i&gt;e&lt;/i&gt;&lt;sup&gt;2&lt;/sup&gt;|)
<span class="lineNum">     733 </span>            :      * @return &lt;i&gt;e&lt;/i&gt; atanh(&lt;i&gt;e x&lt;/i&gt;)
<span class="lineNum">     734 </span>            :      *
<span class="lineNum">     735 </span>            :      * If &lt;i&gt;e&lt;/i&gt;&lt;sup&gt;2&lt;/sup&gt; is negative (&lt;i&gt;e&lt;/i&gt; is imaginary), the
<span class="lineNum">     736 </span>            :      * expression is evaluated in terms of atan.
<span class="lineNum">     737 </span>            :      **********************************************************************/
<span class="lineNum">     738 </span>            :     template&lt;typename T&gt; static T eatanhe(T x, T es);
<span class="lineNum">     739 </span>            : 
<span class="lineNum">     740 </span>            :     /**
<span class="lineNum">     741 </span>            :      * Copy the sign.
<span class="lineNum">     742 </span>            :      *
<span class="lineNum">     743 </span>            :      * @tparam T the type of the argument.
<span class="lineNum">     744 </span>            :      * @param[in] x gives the magitude of the result.
<span class="lineNum">     745 </span>            :      * @param[in] y gives the sign of the result.
<span class="lineNum">     746 </span>            :      * @return value with the magnitude of \e x and with the sign of \e y.
<span class="lineNum">     747 </span>            :      *
<span class="lineNum">     748 </span>            :      * This routine correctly handles the case \e y = &amp;minus;0, returning
<span class="lineNum">     749 </span>            :      * &amp;minus|&lt;i&gt;x&lt;/i&gt;|.
<span class="lineNum">     750 </span>            :      **********************************************************************/
<span class="lineNum">     751 </span>            :     template&lt;typename T&gt; static T copysign(T x, T y) {
<span class="lineNum">     752 </span>            : #if GEOGRAPHICLIB_CXX11_MATH
<span class="lineNum">     753 </span><span class="lineCov">        283 :       using std::copysign; return copysign(x, y);</span>
<span class="lineNum">     754 </span>            : #else
<span class="lineNum">     755 </span>            :       using std::abs;
<span class="lineNum">     756 </span>            :       // NaN counts as positive
<span class="lineNum">     757 </span>            :       return abs(x) * (y &lt; 0 || (y == 0 &amp;&amp; 1/y &lt; 0) ? -1 : 1);
<span class="lineNum">     758 </span>            : #endif
<span class="lineNum">     759 </span>            :     }
<span class="lineNum">     760 </span>            : 
<span class="lineNum">     761 </span>            :     /**
<span class="lineNum">     762 </span>            :      * tan&amp;chi; in terms of tan&amp;phi;
<span class="lineNum">     763 </span>            :      *
<span class="lineNum">     764 </span>            :      * @tparam T the type of the argument and the returned value.
<span class="lineNum">     765 </span>            :      * @param[in] tau &amp;tau; = tan&amp;phi;
<span class="lineNum">     766 </span>            :      * @param[in] es the signed eccentricity = sign(&lt;i&gt;e&lt;/i&gt;&lt;sup&gt;2&lt;/sup&gt;)
<span class="lineNum">     767 </span>            :      *   sqrt(|&lt;i&gt;e&lt;/i&gt;&lt;sup&gt;2&lt;/sup&gt;|)
<span class="lineNum">     768 </span>            :      * @return &amp;tau;&amp;prime; = tan&amp;chi;
<span class="lineNum">     769 </span>            :      *
<span class="lineNum">     770 </span>            :      * See Eqs. (7--9) of
<span class="lineNum">     771 </span>            :      * C. F. F. Karney,
<span class="lineNum">     772 </span>            :      * &lt;a href=&quot;https://doi.org/10.1007/s00190-011-0445-3&quot;&gt;
<span class="lineNum">     773 </span>            :      * Transverse Mercator with an accuracy of a few nanometers,&lt;/a&gt;
<span class="lineNum">     774 </span>            :      * J. Geodesy 85(8), 475--485 (Aug. 2011)
<span class="lineNum">     775 </span>            :      * (preprint
<span class="lineNum">     776 </span>            :      * &lt;a href=&quot;https://arxiv.org/abs/1002.1417&quot;&gt;arXiv:1002.1417&lt;/a&gt;).
<span class="lineNum">     777 </span>            :      **********************************************************************/
<span class="lineNum">     778 </span>            :     template&lt;typename T&gt; static T taupf(T tau, T es);
<span class="lineNum">     779 </span>            : 
<span class="lineNum">     780 </span>            :     /**
<span class="lineNum">     781 </span>            :      * tan&amp;phi; in terms of tan&amp;chi;
<span class="lineNum">     782 </span>            :      *
<span class="lineNum">     783 </span>            :      * @tparam T the type of the argument and the returned value.
<span class="lineNum">     784 </span>            :      * @param[in] taup &amp;tau;&amp;prime; = tan&amp;chi;
<span class="lineNum">     785 </span>            :      * @param[in] es the signed eccentricity = sign(&lt;i&gt;e&lt;/i&gt;&lt;sup&gt;2&lt;/sup&gt;)
<span class="lineNum">     786 </span>            :      *   sqrt(|&lt;i&gt;e&lt;/i&gt;&lt;sup&gt;2&lt;/sup&gt;|)
<span class="lineNum">     787 </span>            :      * @return &amp;tau; = tan&amp;phi;
<span class="lineNum">     788 </span>            :      *
<span class="lineNum">     789 </span>            :      * See Eqs. (19--21) of
<span class="lineNum">     790 </span>            :      * C. F. F. Karney,
<span class="lineNum">     791 </span>            :      * &lt;a href=&quot;https://doi.org/10.1007/s00190-011-0445-3&quot;&gt;
<span class="lineNum">     792 </span>            :      * Transverse Mercator with an accuracy of a few nanometers,&lt;/a&gt;
<span class="lineNum">     793 </span>            :      * J. Geodesy 85(8), 475--485 (Aug. 2011)
<span class="lineNum">     794 </span>            :      * (preprint
<span class="lineNum">     795 </span>            :      * &lt;a href=&quot;https://arxiv.org/abs/1002.1417&quot;&gt;arXiv:1002.1417&lt;/a&gt;).
<span class="lineNum">     796 </span>            :      **********************************************************************/
<span class="lineNum">     797 </span>            :     template&lt;typename T&gt; static T tauf(T taup, T es);
<span class="lineNum">     798 </span>            : 
<span class="lineNum">     799 </span>            :     /**
<span class="lineNum">     800 </span>            :      * Test for finiteness.
<span class="lineNum">     801 </span>            :      *
<span class="lineNum">     802 </span>            :      * @tparam T the type of the argument.
<span class="lineNum">     803 </span>            :      * @param[in] x
<span class="lineNum">     804 </span>            :      * @return true if number is finite, false if NaN or infinite.
<span class="lineNum">     805 </span>            :      **********************************************************************/
<span class="lineNum">     806 </span>            :     template&lt;typename T&gt; static bool isfinite(T x) {
<span class="lineNum">     807 </span>            : #if GEOGRAPHICLIB_CXX11_MATH
<span class="lineNum">     808 </span>            :       using std::isfinite; return isfinite(x);
<span class="lineNum">     809 </span>            : #else
<span class="lineNum">     810 </span>            :       using std::abs;
<span class="lineNum">     811 </span>            : #if defined(_MSC_VER)
<span class="lineNum">     812 </span>            :       return abs(x) &lt;= (std::numeric_limits&lt;T&gt;::max)();
<span class="lineNum">     813 </span>            : #else
<span class="lineNum">     814 </span>            :       // There's a problem using MPFR C++ 3.6.3 and g++ -std=c++14 (reported on
<span class="lineNum">     815 </span>            :       // 2015-05-04) with the parens around std::numeric_limits&lt;T&gt;::max.  Of
<span class="lineNum">     816 </span>            :       // course, these parens are only needed to deal with Windows stupidly
<span class="lineNum">     817 </span>            :       // defining max as a macro.  So don't insert the parens on non-Windows
<span class="lineNum">     818 </span>            :       // platforms.
<span class="lineNum">     819 </span>            :       return abs(x) &lt;= std::numeric_limits&lt;T&gt;::max();
<span class="lineNum">     820 </span>            : #endif
<span class="lineNum">     821 </span>            : #endif
<span class="lineNum">     822 </span>            :     }
<span class="lineNum">     823 </span>            : 
<span class="lineNum">     824 </span>            :     /**
<span class="lineNum">     825 </span>            :      * The NaN (not a number)
<span class="lineNum">     826 </span>            :      *
<span class="lineNum">     827 </span>            :      * @tparam T the type of the returned value.
<span class="lineNum">     828 </span>            :      * @return NaN if available, otherwise return the max real of type T.
<span class="lineNum">     829 </span>            :      **********************************************************************/
<span class="lineNum">     830 </span>            :     template&lt;typename T&gt; static T NaN() {
<span class="lineNum">     831 </span>            : #if defined(_MSC_VER)
<span class="lineNum">     832 </span>            :       return std::numeric_limits&lt;T&gt;::has_quiet_NaN ?
<span class="lineNum">     833 </span>            :         std::numeric_limits&lt;T&gt;::quiet_NaN() :
<span class="lineNum">     834 </span>            :         (std::numeric_limits&lt;T&gt;::max)();
<span class="lineNum">     835 </span>            : #else
<span class="lineNum">     836 </span>            :       return std::numeric_limits&lt;T&gt;::has_quiet_NaN ?
<span class="lineNum">     837 </span>            :         std::numeric_limits&lt;T&gt;::quiet_NaN() :
<span class="lineNum">     838 </span>            :         std::numeric_limits&lt;T&gt;::max();
<span class="lineNum">     839 </span>            : #endif
<span class="lineNum">     840 </span>            :     }
<span class="lineNum">     841 </span>            :     /**
<span class="lineNum">     842 </span>            :      * A synonym for NaN&lt;real&gt;().
<span class="lineNum">     843 </span>            :      **********************************************************************/
<span class="lineNum">     844 </span>            :     static real NaN() { return NaN&lt;real&gt;(); }
<span class="lineNum">     845 </span>            : 
<span class="lineNum">     846 </span>            :     /**
<span class="lineNum">     847 </span>            :      * Test for NaN.
<span class="lineNum">     848 </span>            :      *
<span class="lineNum">     849 </span>            :      * @tparam T the type of the argument.
<span class="lineNum">     850 </span>            :      * @param[in] x
<span class="lineNum">     851 </span>            :      * @return true if argument is a NaN.
<span class="lineNum">     852 </span>            :      **********************************************************************/
<span class="lineNum">     853 </span>            :     template&lt;typename T&gt; static bool isnan(T x) {
<span class="lineNum">     854 </span>            : #if GEOGRAPHICLIB_CXX11_MATH
<span class="lineNum">     855 </span>            :       using std::isnan; return isnan(x);
<span class="lineNum">     856 </span>            : #else
<span class="lineNum">     857 </span>            :       return x != x;
<span class="lineNum">     858 </span>            : #endif
<span class="lineNum">     859 </span>            :     }
<span class="lineNum">     860 </span>            : 
<span class="lineNum">     861 </span>            :     /**
<span class="lineNum">     862 </span>            :      * Infinity
<span class="lineNum">     863 </span>            :      *
<span class="lineNum">     864 </span>            :      * @tparam T the type of the returned value.
<span class="lineNum">     865 </span>            :      * @return infinity if available, otherwise return the max real.
<span class="lineNum">     866 </span>            :      **********************************************************************/
<span class="lineNum">     867 </span>            :     template&lt;typename T&gt; static T infinity() {
<span class="lineNum">     868 </span>            : #if defined(_MSC_VER)
<span class="lineNum">     869 </span>            :       return std::numeric_limits&lt;T&gt;::has_infinity ?
<span class="lineNum">     870 </span>            :         std::numeric_limits&lt;T&gt;::infinity() :
<span class="lineNum">     871 </span>            :         (std::numeric_limits&lt;T&gt;::max)();
<span class="lineNum">     872 </span>            : #else
<span class="lineNum">     873 </span>            :       return std::numeric_limits&lt;T&gt;::has_infinity ?
<span class="lineNum">     874 </span>            :         std::numeric_limits&lt;T&gt;::infinity() :
<span class="lineNum">     875 </span>            :         std::numeric_limits&lt;T&gt;::max();
<span class="lineNum">     876 </span>            : #endif
<span class="lineNum">     877 </span>            :     }
<span class="lineNum">     878 </span>            :     /**
<span class="lineNum">     879 </span>            :      * A synonym for infinity&lt;real&gt;().
<span class="lineNum">     880 </span>            :      **********************************************************************/
<span class="lineNum">     881 </span>            :     static real infinity() { return infinity&lt;real&gt;(); }
<span class="lineNum">     882 </span>            : 
<span class="lineNum">     883 </span>            :     /**
<span class="lineNum">     884 </span>            :      * Swap the bytes of a quantity
<span class="lineNum">     885 </span>            :      *
<span class="lineNum">     886 </span>            :      * @tparam T the type of the argument and the returned value.
<span class="lineNum">     887 </span>            :      * @param[in] x
<span class="lineNum">     888 </span>            :      * @return x with its bytes swapped.
<span class="lineNum">     889 </span>            :      **********************************************************************/
<span class="lineNum">     890 </span>            :     template&lt;typename T&gt; static T swab(T x) {
<span class="lineNum">     891 </span>            :       union {
<span class="lineNum">     892 </span>            :         T r;
<span class="lineNum">     893 </span>            :         unsigned char c[sizeof(T)];
<span class="lineNum">     894 </span>            :       } b;
<span class="lineNum">     895 </span><span class="lineNoCov">          0 :       b.r = x;</span>
<span class="lineNum">     896 </span><span class="lineNoCov">          0 :       for (int i = sizeof(T)/2; i--; )</span>
<span class="lineNum">     897 </span><span class="lineNoCov">          0 :         std::swap(b.c[i], b.c[sizeof(T) - 1 - i]);</span>
<span class="lineNum">     898 </span><span class="lineNoCov">          0 :       return b.r;</span>
<span class="lineNum">     899 </span>            :     }
<span class="lineNum">     900 </span>            : 
<span class="lineNum">     901 </span>            : #if GEOGRAPHICLIB_PRECISION == 4
<span class="lineNum">     902 </span>            :     typedef boost::math::policies::policy
<span class="lineNum">     903 </span>            :       &lt; boost::math::policies::domain_error
<span class="lineNum">     904 </span>            :         &lt;boost::math::policies::errno_on_error&gt;,
<span class="lineNum">     905 </span>            :         boost::math::policies::pole_error
<span class="lineNum">     906 </span>            :         &lt;boost::math::policies::errno_on_error&gt;,
<span class="lineNum">     907 </span>            :         boost::math::policies::overflow_error
<span class="lineNum">     908 </span>            :         &lt;boost::math::policies::errno_on_error&gt;,
<span class="lineNum">     909 </span>            :         boost::math::policies::evaluation_error
<span class="lineNum">     910 </span>            :         &lt;boost::math::policies::errno_on_error&gt; &gt;
<span class="lineNum">     911 </span>            :       boost_special_functions_policy;
<span class="lineNum">     912 </span>            : 
<span class="lineNum">     913 </span>            :     static real hypot(real x, real y)
<span class="lineNum">     914 </span>            :     { return boost::math::hypot(x, y, boost_special_functions_policy()); }
<span class="lineNum">     915 </span>            : 
<span class="lineNum">     916 </span>            :     static real expm1(real x)
<span class="lineNum">     917 </span>            :     { return boost::math::expm1(x, boost_special_functions_policy()); }
<span class="lineNum">     918 </span>            : 
<span class="lineNum">     919 </span>            :     static real log1p(real x)
<span class="lineNum">     920 </span>            :     { return boost::math::log1p(x, boost_special_functions_policy()); }
<span class="lineNum">     921 </span>            : 
<span class="lineNum">     922 </span>            :     static real asinh(real x)
<span class="lineNum">     923 </span>            :     { return boost::math::asinh(x, boost_special_functions_policy()); }
<span class="lineNum">     924 </span>            : 
<span class="lineNum">     925 </span>            :     static real atanh(real x)
<span class="lineNum">     926 </span>            :     { return boost::math::atanh(x, boost_special_functions_policy()); }
<span class="lineNum">     927 </span>            : 
<span class="lineNum">     928 </span>            :     static real cbrt(real x)
<span class="lineNum">     929 </span>            :     { return boost::math::cbrt(x, boost_special_functions_policy()); }
<span class="lineNum">     930 </span>            : 
<span class="lineNum">     931 </span>            :     static real fma(real x, real y, real z)
<span class="lineNum">     932 </span>            :     { return fmaq(__float128(x), __float128(y), __float128(z)); }
<span class="lineNum">     933 </span>            : 
<span class="lineNum">     934 </span>            :     static real copysign(real x, real y)
<span class="lineNum">     935 </span>            :     { return boost::math::copysign(x, y); }
<span class="lineNum">     936 </span>            : 
<span class="lineNum">     937 </span>            :     static bool isnan(real x) { return boost::math::isnan(x); }
<span class="lineNum">     938 </span>            : 
<span class="lineNum">     939 </span>            :     static bool isfinite(real x) { return boost::math::isfinite(x); }
<span class="lineNum">     940 </span>            : #endif
<span class="lineNum">     941 </span>            :   };
<span class="lineNum">     942 </span>            : 
<span class="lineNum">     943 </span>            : } // namespace GeographicLib
<span class="lineNum">     944 </span>            : 
<span class="lineNum">     945 </span>            : #endif  // GEOGRAPHICLIB_MATH_HPP
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>
